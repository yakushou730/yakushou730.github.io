<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<title class=pjax-title>Certified K8s Administrator - YakuShou's NOTEBOOK</title><meta name=Description content="Certified K8s Administrator"><meta property="og:title" content="Certified K8s Administrator">
<meta property="og:description" content="Certified K8s Administrator">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.yakushou.com/posts/k8s/certified-k8s-administrator/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-01-09T21:07:35+08:00">
<meta property="article:modified_time" content="2022-01-09T21:07:35+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Certified K8s Administrator">
<meta name=twitter:description content="Certified K8s Administrator">
<meta name=application-name content="YakuShou's NOTEBOOK">
<meta name=apple-mobile-web-app-title content="YakuShou's NOTEBOOK">
<meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://blog.yakushou.com/posts/k8s/certified-k8s-administrator/><link rel=prev href=https://blog.yakushou.com/posts/k8s/helm/><link rel=next href=https://blog.yakushou.com/posts/programming/tools/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/fontawesome-free/all.min.css>
<noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/animate/animate.min.css>
<noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Certified K8s Administrator","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.yakushou.com\/posts\/k8s\/certified-k8s-administrator\/"},"genre":"posts","keywords":"programming, k8s","wordcount":1137,"url":"https:\/\/blog.yakushou.com\/posts\/k8s\/certified-k8s-administrator\/","datePublished":"2022-01-09T21:07:35+08:00","dateModified":"2022-01-09T21:07:35+08:00","publisher":{"@type":"Organization","name":"Author"},"authors":[{"@type":"Person","name":"yakushou730"}],"description":"Certified K8s Administrator"}</script></head>
<body header-desktop header-mobile><script type=text/javascript>function setTheme(a){document.body.setAttribute('theme',a)}function saveTheme(a){window.localStorage&&localStorage.setItem('theme',a)}function getMeta(b){const a=document.getElementsByTagName('meta');for(let c=0;c<a.length;c++)if(a[c].getAttribute('name')===b)return a[c];return''}if(window.localStorage&&localStorage.getItem('theme')){let a=localStorage.getItem('theme');a==='light'||a==='dark'||a==='black'?setTheme(a):window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches?setTheme('dark'):setTheme('light')}else''==='light'||''==='dark'||''==='black'?(setTheme(''),saveTheme('')):(saveTheme('auto'),window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches?setTheme('dark'):setTheme('light'));let metaColors={light:'#f8f8f8',dark:'#252627',black:'#000000'};getMeta('theme-color').content=metaColors[document.body.getAttribute('theme')]</script>
<div id=back-to-top></div>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="YakuShou's NOTEBOOK">YakuShou's NOTEBOOK</a>
</div>
<div class=menu>
<div class=menu-inner><a class=menu-item href=/posts/> Posts </a><a class=menu-item href=/tags/> Tags </a><span class="menu-item delimiter"></span><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a></div>
</div>
</div>
</header><header class=mobile id=header-mobile>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="YakuShou's NOTEBOOK">YakuShou's NOTEBOOK</a>
</div>
<div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div>
</div>
<div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a></div>
</div>
</header>
<div class="search-dropdown desktop">
<div id=search-dropdown-desktop></div>
</div>
<div class="search-dropdown mobile">
<div id=search-dropdown-mobile></div>
</div>
<main class=main>
<div class=container><div class=toc id=toc-auto>
<h2 class=toc-title>Contents</h2>
<div class=toc-content id=toc-content-auto></div>
</div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle","normal")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Certified K8s Administrator</h1><div class=post-meta>
<div class=post-meta-line>
<span class=post-author><span class=author><i class="author fas fa-user-circle fa-fw"></i><span class=screen-reader-text> </span><a href=https://blog.yakushou.com/authors/yakushou730>yakushou730</a></span>
</span></div>
<div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-01-09>2022-01-09</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2022-01-09>2022-01-09</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;1137 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;6 minutes&nbsp;</div>
</div><div class="details toc" id=toc-static kept>
<div class="details-summary toc-title">
<span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span>
</div>
<div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents>
<ul>
<li><a href=#core-concepts>Core Concepts</a></li>
<li><a href=#etcd>ETCD</a></li>
<li><a href=#kube-api-server>Kube API Server</a></li>
<li><a href=#kube-controller-manager>Kube Controller Manager</a></li>
<li><a href=#kube-scheduler>kube scheduler</a></li>
<li><a href=#kubelet>Kubelet</a></li>
<li><a href=#kube-proxy>Kube Proxy</a></li>
<li><a href=#namespace>Namespace</a></li>
<li><a href=#imperative-vs-declarative>Imperative vs Declarative</a></li>
<li><a href=#kubectl-apply-command>Kubectl apply command</a></li>
<li><a href=#manual-scheduling>Manual Scheduling</a></li>
<li><a href=#labels-and-selectors>Labels and Selectors</a></li>
<li><a href=#taints-and-tolerations>Taints and Tolerations</a></li>
<li><a href=#node-selectors>Node Selectors</a></li>
</ul>
</nav></div>
</div><div class=content id=content><h2 id=core-concepts>Core Concepts</h2>
<blockquote>
<p>k8s 的目的是要以自動化的形式管理 container 形式的 app</p>
<p>讓使用者可以簡單的部署，並讓各服務的溝通可以簡單化</p>
</blockquote>
<p>解說:</p>
<p>假設現在有兩艘船，cargo ship 和 control ship</p>
<ul>
<li>Cargo Ship
<ul>
<li>負責實際運載 container 的工作</li>
<li>每艘船的船長，負責管理船上的 activities，負責接收當 master 需要裝載 container 時的資訊，
並回報給 master 這艘船的狀態和 container 的狀態</li>
</ul>
</li>
<li>Control Ship
<ul>
<li>負責監測和管理 cargo ships</li>
<li>透過 control plane 元件負責管理 cargo ship 的大小事</li>
<li>ETCD: 每天都有很多 container 要被載到 cargo ships 上，所以需要紀錄不同的船上有哪個 container，包含載入的時間
而這些是以 key-value 的形式被保存的</li>
<li>kube-scheduler: 當 cargo ship 來的時候，要負責判斷並把對應的 container 奘載給他</li>
<li>Controller manager:
<ul>
<li>指派特殊工作，例: operation team 要處理交通控制，或是 container 壞掉的時候，怎麼樣建立一個可以用的 container</li>
<li>service office 用來讓各部門溝通，或是讓不同的船之間溝通</li>
</ul>
</li>
</ul>
</li>
<li>最高部門: kube-apiserver，各部門之間管理的最高層級，負責 Cluster 的工作協調</li>
</ul>
<p>對應到 k8s 的名詞</p>
<ul>
<li>Worker Nodes: host Application as Containers
<ul>
<li>Container Runtime Engine: 讓 node 可以處理 container</li>
<li>kubelet: 船長的角色，是一個裝在 node 上的 agent，接收來自 kube-apiserver 的指令，在 node 上 deploy 或 destroy container</li>
<li>kube-proxy: 讓 nodes 之間可以知道要溝通的服務在哪邊 (web container 對應 db container)</li>
</ul>
</li>
<li>Master: Manage, Plan, Schedule, Monitor Nodes
<ul>
<li>ETCD Cluster: 一個 key-value 的資料庫</li>
<li>kube-scheduler: 負責把 container 起在對應的 node 上
<ul>
<li>可能包含的條件有 resource requirements for nodes capacity, policies, &mldr;etc</li>
</ul>
</li>
<li>Controller manager
<ul>
<li>Node-Controller: 處理新增/刪除 node，以及處理出問題的 node</li>
<li>Replication-Controller: 確保期望的 container 數量都是對的</li>
</ul>
</li>
<li>kube-apiserver: 管理 cluster 的最高層級，提供 k8s API 來讓使用者操作
定時監控 kubelet 上 node 和 container 的狀態報告</li>
</ul>
</li>
</ul>
<h2 id=etcd>ETCD</h2>
<blockquote>
<p>ETCD is a distributed reliable key-value store that is simple, secure & fast</p>
</blockquote>
<p>default port: 2379</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># 安裝完後執行 binary 檔案</span>
./etcd
<span class=c1># 設定 key-value</span>
./etcdctl <span class=nb>set</span> key1 value1
<span class=c1># 取得 value</span>
./etcdctl get key1 <span class=c1># 得到 value1</span>
<span class=c1># help</span>
./etcdctl
</code></pre></div><p>所有 k8s 上要紀錄的資料都會更新在 etcd datastore 上，然後才會在 cluster 上生效</p>
<p>不同的安裝方式</p>
<ol>
<li>自己獨立安裝的，把 binary 檔案設定成 service 並執行
<ul>
<li>需要注意的欄位 <code>--advertise-client-urls https://${INTERNAL_IP}:2379</code>，這是要設定在 apiserver 上的 url</li>
</ul>
</li>
<li>透過 kubeadm 安裝的
<ul>
<li>會把 etcd 做成 pod 安裝在 cluster 上 kube-system 的 namespace 中</li>
<li>所以可以進到 pod 裡面並操作 key-value store</li>
<li>多 cluster 的情況，要注意的欄位是 <code>--initial-cluster controller-0=https://${CONTROLLER0_IP}:2380,controller-1=https://${CONTROLLER1_IP}:2380</code></li>
</ul>
</li>
</ol>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell>kubectl <span class=nb>exec</span> etcd-master -n kube-system etcdctl get / --prefix -keys-only
</code></pre></div><h2 id=kube-api-server>Kube API Server</h2>
<p>當執行 <code>kubectl</code> 的時候，就是在發 API 給 kube-apiserver</p>
<ol>
<li>以 <code>kubectl get pods</code> 為例</li>
</ol>
<p>kube-apiserver 會先做 authenticate 和 validate，再去 ETCD 拿 pods 資料回給 使用者</p>
<ol start=2>
<li>以建立 pods 為例</li>
</ol>
<p>kube-apiserver 做完 authenticate 和 validate 以後，會先建立一個 pod (還不在任何 node 上)</p>
<p>先更新到 ETCD 上，再回應 使用者 <code>Pod created!</code></p>
<p>接著 scheduler 持續監控 apiserver，發現了這個沒有在 node 上的 pod</p>
<p>scheduler 識別出正確的 node 來放這個新的 pod，並通知 apiserver</p>
<p>apiserver 再把這資訊寫進 ETCD 並且把資訊傳給對應 worker node 的 kubelet</p>
<p>收到資訊的 node 就建立這個 pod 出來 (透過 Container Runtime Enginer 部署 image)</p>
<p>完成後 kubelet 把資訊回傳給 kube-apiserver，apiserver 再把資訊寫進 ETCD</p>
<blockquote>
<p>可以注意到幾乎全部的溝通都要通過 apiserver</p>
</blockquote>
<p>整合剛剛的步驟</p>
<ol>
<li>Authenticate User</li>
<li>Validate Request</li>
<li>Retrieve data</li>
<li>Update ETCD</li>
<li>Scheduler</li>
<li>Kubelet</li>
</ol>
<h2 id=kube-controller-manager>Kube Controller Manager</h2>
<p>Controller manager 管理了許多 k8s 不同的 controller</p>
<p>Controller 可以負責的任務</p>
<ul>
<li>當有新船抵達或是有船離開，監控並做出必要的動作</li>
<li>管理船上的 container</li>
</ul>
<p>簡化:</p>
<ol>
<li>狀態監控 (Watch status)</li>
<li>情況補救 (Remediate situation)</li>
</ol>
<blockquote>
<p>k8s 中，controller 是一個程序 會持續監控系統中的 component 狀態</p>
<p>並做出處置讓整個系統可以處在 desired state</p>
</blockquote>
<p>Node Controller</p>
<ul>
<li>監控 node 狀態，以及做出處置讓 application 可以持續運作</li>
<li>中間要透過 apiserver</li>
<li>node controller 每 5秒 確認一次 node 的狀態</li>
<li>如果 node controller 超過 40秒 讀不到 node 的 heartbeat，那該 node 會被標為 unreachable</li>
<li>如果標為 unreachable 超過 5分鐘，就註銷那個 node 上面的 pod，並移去其他健康的 node (如果那個 pod 是在 replicaset 之中的話)</li>
</ul>
<p>Replication Controller</p>
<ul>
<li>監控 replicaset 狀態，並確保預期的 pod 數量正常的，如果有 pod 掛了就建立新的</li>
</ul>
<blockquote>
<p>一堆 controller 組合起來，就像 k8s 的大腦，整個包起來就是 kube-controller-manager</p>
</blockquote>
<h2 id=kube-scheduler>kube scheduler</h2>
<p>負責決定 哪個 pod 要去哪個 node，但不是 scheduler 操作把 pod 放去哪 (這是 kubelet 的工作)</p>
<blockquote>
<p>kubelet 會負責建立 pod</p>
</blockquote>
<p>為什麼需要 scheduler ?</p>
<ul>
<li>因為每個 container 的大小或需要的環境都不太一樣，所以需要特別處理來讓生產效益最高</li>
</ul>
<p>scheduler 的決定流程</p>
<ol>
<li>先看 container 的環境需求，首先 filter nodes，讓不滿條件的 node 先排除
<ul>
<li>比如說 CUP, memory 不滿足&mldr;等等</li>
</ul>
</li>
<li>再做 rank nodes，會有一個 priority function 來對每個 node 做評分</li>
</ol>
<h2 id=kubelet>Kubelet</h2>
<p>kubelet 是 worker node 上面的船長，負責和 apiserver 溝通</p>
<p>負責 container 的裝載，並回報給 master</p>
<p>負責</p>
<ol>
<li>Register Node (to cluster)</li>
<li>Create Pod</li>
<li>Monitor Nodes & Pods</li>
</ol>
<h2 id=kube-proxy>Kube Proxy</h2>
<p>Pod Network 讓 cluster 內的 pod 可以互相溝通</p>
<p>先前學過的 相互溝通可以透過 Service object</p>
<p>network 不是實體，所以不會建立 pod，而是紀錄在 memory 裡面</p>
<p>kube-proxy 是一個 process，在每個 node 上執行</p>
<p>每當有新的 service 被發現，就會在每個 node 上建立對應的 rules 來導流量給這些 service 到 pod</p>
<ul>
<li>IP table</li>
</ul>
<h2 id=namespace>Namespace</h2>
<p>k8s 常用的 namespace</p>
<ul>
<li>default</li>
<li>kube-system</li>
<li>kube-public</li>
</ul>
<p>namespace 是可以有 policy 權限控管的</p>
<p>也可以對 namespace 做資源上的限制</p>
<p>舉例:
namespace: default</p>
<ul>
<li>web-pod</li>
<li>db-service</li>
<li>web-deployment
namespace: dev</li>
<li>db-service</li>
<li>web-pod</li>
</ul>
<p>如果 default 內的 web-pod 要對同 namespace 的 db-service 存取，使用 <code>mysql.connect("db-service")</code></p>
<p>如果 default 內的 web-pod 要對 dev namespace 的 db-service 存取，使用 <code>mysql.connect("db-service.dev.svc.cluster.local")</code></p>
<ul>
<li><code>cluster.local</code> 是 default domain name for k8s</li>
<li><code>svc</code> 是 subdomain for service</li>
<li><code>dev</code> 是 namespace</li>
<li><code>db-service</code> 是 service name</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># 指令建立 namespace 名稱 dev-ns</span>
kubectl create ns dev-ns
<span class=c1># 列出 namespace default 的 pods</span>
kubectl get pods
<span class=c1># 列出指定 namespace 的 pods</span>
kubectl get pods --namespace<span class=o>=</span>kube-system
<span class=c1># 建立 pod 到指定的 namespace</span>
kubectl create -f pod-definition.yaml --namespace<span class=o>=</span>dev
</code></pre></div><p>在 pod-definition.yaml 裡面指定 namespace</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=c># 假設指定 namespace dev</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>dev</span><span class=w>
</span></code></pre></div><p>切換 namespace</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># context 是 cluster</span>
kubectl config set-context <span class=k>$(</span>kubectl config current-context<span class=k>)</span> --namespace<span class=o>=</span>&lt;target namspace&gt;
<span class=c1># 當前 cluster</span>
kubectl config set-context --current --namespace<span class=o>=</span>&lt;target namespace&gt;
</code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># 列出所有 namespace 下的 pod</span>
kubectl get pods --all-namespaces
</code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># 常用指令</span>
<span class=c1># --no-headers 是指不要印出 header 行</span>

<span class=c1># 其他組合</span>
kubectl get ns --no-headers <span class=p>|</span> wc -l
kubectl get po -n research --no-headers <span class=p>|</span> wc -l
</code></pre></div><blockquote>
<p>練習中有一個範例是在 pod 顯示頁面輸入 host 和 port 來連線到 redis</p>
<p>host 要是 能連到 db pod 的 service name，而不是 db 的 pod name</p>
</blockquote>
<h2 id=imperative-vs-declarative>Imperative vs Declarative</h2>
<p>以搭計程車為例:</p>
<ul>
<li>Imperative: 告訴司機先往左，再往右，再直走&mldr; 等等等步驟
<ul>
<li>重點是 how to do</li>
</ul>
</li>
<li>Declarative: 直接告訴司機終點地址
<ul>
<li>重點是 最後結果 (what to do)</li>
</ul>
</li>
</ul>
<p>以 Infrastructure as Code 為例</p>
<p>Imperative</p>
<pre tabindex=0><code>1. Provision a VM by the name 'web-server'
2. Install NGINX Software on it
3. Edit configuration file to use port 8080
4. Edit configuration file to web path '/var/www/nginx'
5. Load web pages to '/var/www/nginx' from GIT Repo - X
6. Start NGINX server
</code></pre><p>Declarative</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=nt>VM NAME</span><span class=p>:</span><span class=w> </span><span class=l>web-server</span><span class=w>
</span><span class=w></span><span class=nt>Package</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span><span class=w></span><span class=nt>Port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span><span class=w></span><span class=nt>Path</span><span class=p>:</span><span class=w> </span><span class=l>/var/www/nginx</span><span class=w>
</span><span class=w></span><span class=nt>Code</span><span class=p>:</span><span class=w> </span><span class=l>GIT Repo - X</span><span class=w>
</span></code></pre></div><p>以 Kubernetes 為例</p>
<p>Imperative</p>
<ul>
<li>透過數個 <code>kubectl create</code> 指令來建立 pod / deployment &mldr;.等等等</li>
<li>要自己手動下指令調整各種設定</li>
<li>不需要 configuration file</li>
<li>很難 track，換個人就不知道怎麼操作了</li>
</ul>
<p>Declarative</p>
<ul>
<li>只要透過 <code>kubectl apply</code> 使用定義好的 configuration file，其他邏輯都不用管</li>
</ul>
<h2 id=kubectl-apply-command>Kubectl apply command</h2>
<p>系統會比對設定檔的差異</p>
<p><code>Local file</code> &lt;-> 比對 k8s <code>Live object configuration</code> (in memory)</p>
<p>如果不一樣的話就會更新，並把最新的版本更新到 <code>Last applied Configuration</code></p>
<ul>
<li>這資料是存在 k8s Live Object Configuration 的 <code>metadata.annotations.kubectl.kubernetes.io/last-applied-configuration</code></li>
<li>要透過 <code>kubectl apply</code> 才會生成，<code>kubectl create</code> 或 <code>kubectl replace</code> 是不會更新這資料的</li>
</ul>
<h2 id=manual-scheduling>Manual Scheduling</h2>
<p>Pod 在 k8s 上的 live object configuration 上面會被賦予 <code>nodeName</code></p>
<p>而 scheduler 是專門查 pod 上誰沒有 nodeName，發現的話就用自己的演算法賦予 node 上去</p>
<blockquote>
<p>k8s 不給修改已經賦予 nodeName 的 pod 上面的 nodeName</p>
</blockquote>
<p>pod-bind-definition.yaml</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Binding</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span><span class=w></span><span class=nt>target</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span><span class=w>  </span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Node</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>node2</span><span class=w>
</span></code></pre></div><p>再把上面的 yaml 轉成 json 後 post 給 k8s 做處理</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># 檢查 scheduler 是否在 k8s 上</span>
kubectl get pods --namespace kube-system
</code></pre></div><h2 id=labels-and-selectors>Labels and Selectors</h2>
<p>用來分群的</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># 透過 selector 來 filter 特定 label 的資料</span>
kubectl get pods --selector <span class=nv>app</span><span class=o>=</span>App1
<span class=c1># 多個 labels 用逗號隔開</span>
kubectl get pods --selector <span class=nv>env</span><span class=o>=</span>prod,bu<span class=o>=</span>finance,tier<span class=o>=</span>frontend
</code></pre></div><p><strong>Annotations</strong></p>
<p>用來儲存其他資訊</p>
<h2 id=taints-and-tolerations>Taints and Tolerations</h2>
<p>解釋如何決定並把 pod 放到對應 node 上的機制 (限制哪些 pod 可以被 scheduled)</p>
<p>如果要避免把 pod 放到某個 node，就對那個 node 做 taint (又叫污點)</p>
<p>再來是把想要有抵抗力的 pod 做 toleration，這樣就可以被放到那個 node 裡面</p>
<p>所以</p>
<ul>
<li>taint 是設定在 node 上</li>
<li>toleration 是設定在 pod 上</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># 語法</span>
<span class=c1># taint-effect 是指 如果 POD 無法 tolerate 這個 taint 的話會怎麼樣</span>
<span class=c1># 其中 taint-effect 可以為 NoSchedule | PreferNoSchedule | NoExecute</span>
<span class=c1># NoSchedule: 不會被 schedule 到這個 node</span>
<span class=c1># PreferNoSchedule: 盡量不要把 pod 放到這個 node</span>
<span class=c1># NoExecute: 不會被 schedule 到這個 node 而且已經在上面的 pod 也會被趕走</span>
kubectl taint nodes node-name key-value:taint-effect
<span class=c1># 範例</span>
kubectl taint nodes node1 <span class=nv>app</span><span class=o>=</span>blue:NoExecute
</code></pre></div><p>對應在 pod spec 上的設定</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>myapp-pod</span><span class=w>
</span><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx-controller</span><span class=w>
</span><span class=w>      </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span><span class=w>  </span><span class=nt>tolerations</span><span class=p>:</span><span class=w> </span><span class=c># 注意要用 double quotes</span><span class=w>
</span><span class=w>    </span>- <span class=nt>key</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;app&#34;</span><span class=w>
</span><span class=w>      </span><span class=nt>operator</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;Equal&#34;</span><span class=w>
</span><span class=w>      </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;blue&#34;</span><span class=w>
</span><span class=w>      </span><span class=nt>effect</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;NoSchedule&#34;</span><span class=w>
</span></code></pre></div><blockquote>
<p>master node 天生就被給予了 taint，pod 不會被放上去</p>
</blockquote>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># 查看 taint</span>
kubectl describe node kubemaster <span class=p>|</span> grep Taint
<span class=c1># 移除 taint [原本的 taint 是 node-role.kubernetes.io/master:NoSchedule]</span>
<span class=c1># 看起來是最後面加個減號可以拿掉</span>
kubectl taint nodes controlplane node-role.kubernetes.io/master:NoSchedule-
</code></pre></div><blockquote>
<p>create pod 是可以直接指定命名 pod 名稱的</p>
<p>kubectl run mosquito &ndash;image=nginx &ndash;restart=Never</p>
<p>查看 pod 的欄位</p>
<p>kubectl explain pod &ndash;recursive | less</p>
<p>pod 的 toleration 是要自己加上去的，才可以 tolerate taint</p>
</blockquote>
<p>當 node 設定 taint 的時候，pod 要上上去的話就一定要具備 toleration</p>
<p>移除 node 上的 taint (在最後面放上 <code>-</code>)</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell>kubectl taint node master node-role.kubernetes.io/master:NoSchedule-
</code></pre></div><h2 id=node-selectors>Node Selectors</h2>
<p>對 node 下標籤</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=c1># 格式</span>
kubectl label nodes &lt;node-name&gt; &lt;label-key&gt;<span class=o>=</span>&lt;label-value&gt;
<span class=c1># 範例: 在 node-1 這台標上 size=Large 的標籤</span>
kubectl label nodes node-1 <span class=nv>size</span><span class=o>=</span>Large
</code></pre></div><p>這樣子 pod 就可以指定要放到對應的 node 上</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>myapp-pod</span><span class=w>
</span><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>data-processor</span><span class=w>
</span><span class=w>      </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>data-processor</span><span class=w>
</span><span class=w>  </span><span class=nt>nodeSelector</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>size</span><span class=p>:</span><span class=w> </span><span class=l>Large</span><span class=w>
</span></code></pre></div><p>更複雜一點的條件的話，會用 Node Affinity</p>
</div>
<div class=post-footer id=post-footer>
<div class=post-info>
<div class=post-info-line>
<div class=post-info-mod>
<span>Updated on 2022-01-09</span>
</div>
<div class=post-info-license></div>
</div>
<div class=post-info-line>
<div class=post-info-md></div>
<div class=post-info-share>
<span></span>
</div>
</div>
</div>
<div class=post-info-more>
<section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/programming/>programming</a>,&nbsp;<a href=/tags/k8s/>k8s</a></section>
<section>
<span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span>
</section>
</div>
<div class=post-nav><a href=/posts/k8s/helm/ class=prev rel=prev title=helm><i class="fas fa-angle-left fa-fw"></i>helm</a>
<a href=/posts/programming/tools/ class=next rel=next title=tools>tools<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
</main><footer class=footer>
<div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.89.2">Hugo</a> | Theme - <a href=https://github.com/HEIGE-PCloud/DoIt target=_blank rel="noopener noreffer" title="DoIt 0.2.13"><i class="far fa-edit fa-fw"></i> DoIt</a>
</div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank rel="noopener noreferrer"></a></span></div>
</div></footer></div>
<div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title="Back to Top">
<i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments">
<i class="fas fa-comment fa-fw"></i>
</a>
</div><div class=assets><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/topbar/topbar.min.js></script><script type=text/javascript src=/lib/pjax/pjax.min.js></script><script type=text/javascript src=/js/theme.min.js></script></div>
<div class=pjax-assets><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:10},comment:{}}</script></div>
</body>
</html>