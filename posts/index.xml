<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts - YakuShou's NOTEBOOK</title><link>https://blog.yakushou.com/posts/</link><description>All Posts | YakuShou's NOTEBOOK</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 23 Jan 2022 21:41:43 +0800</lastBuildDate><atom:link href="https://blog.yakushou.com/posts/" rel="self" type="application/rss+xml"/><item><title>Ultimate Service V3</title><link>https://blog.yakushou.com/posts/golang/ardanlabs/ultimate-service-v3/</link><pubDate>Sun, 23 Jan 2022 21:41:43 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/ardanlabs/ultimate-service-v3/</guid><description><![CDATA[Modules Project:
 a repo of code defines the philosophy, policy and guideline  go mod init [module name] # 範例 go mod init github.com/ardanlabs/service3-video go env # GOMODCACHE=&#34;指向 module cache&#34; GOPROXY=&#34;proxy的位址和方式&#34; GONOPROXY=&#34;這個位址的不要透過proxy，表示直接抓這個位址&#34; # 清掉 module cache go clean -modcache # 自動處理專案的 import go mod tidy go.mod 會存放這個專案會用到的 dependency module
go.sum 會存放用來驗證要用到的 dependency module 的編碼
每當 proxy 抓到新版時，就會另外算出 checksum 放在 checksum DB，讓之後其他人抓 module 的時候可以比對是不是正確的 module
# 建立 vendor 資料夾並把相依抓下來放到這個目錄下 # 這樣專案就會直接找這個資料夾下的資料 go mod vendor  如果發生抓下來的 module 出現 incompatible 怎麼辦?]]></description></item><item><title>Ultimate Go</title><link>https://blog.yakushou.com/posts/golang/ardanlabs/ultimate-go/</link><pubDate>Sat, 22 Jan 2022 14:41:10 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/ardanlabs/ultimate-go/</guid><description>Design Guideline Memory &amp;amp; Data semantics</description></item><item><title>Refactor With Bill</title><link>https://blog.yakushou.com/posts/golang/ardanlabs/refactor-with-bill/</link><pubDate>Sat, 22 Jan 2022 13:46:18 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/ardanlabs/refactor-with-bill/</guid><description>Project init 結構會是先建出下列資料夾 (一個 repo 可以執行多個 binary 的結構)
再來是做 go mod init [name]
# 可執行的程式入口 cmd/violin/css/ cmd/violin/image/ cmd/violin/mp3/ cmd/violin/templates/ cmd/violin/internal/ cmd/violin/main.go # 商業邏輯 internal/platform/ go.mod 起手式 main.go
func main(){ if err := run(); err != nil { log.Println(err) os.Exit(1) } } func run() { return nil }</description></item><item><title>ultimate `syntax</title><link>https://blog.yakushou.com/posts/golang/ardanlabs/ultimate-syntax/</link><pubDate>Tue, 18 Jan 2022 08:25:04 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/ardanlabs/ultimate-syntax/</guid><description>Variables 一般來說使用 int 較多，而不是 int32 或 int64 少用 := zero value，碰到 zero value 的話不如直接用 var 宣吿 Strings string 是 2 words 的 data structures 空字串 第一個 word 是 nil 第二個 word 是 0 字串 Hello 第一個 word 是指標，指向 hello 陣列的 h 位址 第二個 word 是長度 5 Struct golang 的三種印出格式
%v -&amp;gt; {false 0 0} %+v -&amp;gt; {flag:false counter:0 pi:0} %#v -&amp;gt; main.</description></item><item><title>tools</title><link>https://blog.yakushou.com/posts/programming/tools/</link><pubDate>Mon, 10 Jan 2022 10:29:47 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/programming/tools/</guid><description>cloc https://github.com/AlDanial/cloc
計算 檔案數量 / 行數 等等的工具
可以使用 docker container 來跑，就不用安裝 binary
# 最後的 . 是指當前目錄，可以換成對應的目錄 docker run --rm -v $PWD:/tmp aldanial/cloc . commitizen https://github.com/commitizen/cz-cli
可以簡單產生 commitizen 的 git commit
https://www.conventionalcommits.org/en/v1.0.0/
安裝:
npm install commitizen commitizen init cz-conventional-changelog --save-dev --save-exact</description></item><item><title>Certified K8s Administrator</title><link>https://blog.yakushou.com/posts/k8s/certified-k8s-administrator/</link><pubDate>Sun, 09 Jan 2022 21:07:35 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/k8s/certified-k8s-administrator/</guid><description>Core Concepts k8s 的目的是要以自動化的形式管理 container 形式的 app
讓使用者可以簡單的部署，並讓各服務的溝通可以簡單化
解說:
假設現在有兩艘船，cargo ship 和 control ship
Cargo Ship 負責實際運載 container 的工作 每艘船的船長，負責管理船上的 activities，負責接收當 master 需要裝載 container 時的資訊， 並回報給 master 這艘船的狀態和 container 的狀態 Control Ship 負責監測和管理 cargo ships 透過 control plane 元件負責管理 cargo ship 的大小事 ETCD: 每天都有很多 container 要被載到 cargo ships 上，所以需要紀錄不同的船上有哪個 container，包含載入的時間 而這些是以 key-value 的形式被保存的 kube-scheduler: 當 cargo ship 來的時候，要負責判斷並把對應的 container 奘載給他 Controller manager: 指派特殊工作，例: operation team 要處理交通控制，或是 container 壞掉的時候，怎麼樣建立一個可以用的 container service office 用來讓各部門溝通，或是讓不同的船之間溝通 最高部門: kube-apiserver，各部門之間管理的最高層級，負責 Cluster 的工作協調 對應到 k8s 的名詞</description></item><item><title>helm</title><link>https://blog.yakushou.com/posts/k8s/helm/</link><pubDate>Thu, 06 Jan 2022 15:51:08 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/k8s/helm/</guid><description>What is Helm 一般來說，要 deploy 一個服務，即使是簡單的 app
也要建立一整套完整的 k8s 元件
ex: Secret, Deployment, Service, PersistentVolumeClaim&amp;hellip; 等等，需要 apply 一堆 yaml 檔案
Helm 被稱為 k8s 的 package manager
想像一個遊戲由千百個檔案組成
我們不需要自己處理那摩多檔案，透過安裝程式的方式
做到一次安裝一個完整的遊戲，對應的檔案也都被安裝到正確的位置
而 Helm 就像這樣，一次處理一堆 YAML 檔案和 K8s 物件，來設定 application
Helm 讓我們操作 k8s 的元件就像操作 app 一樣，而不是一堆檔案物件
# 透過 helm 安裝 wordpress helm install wordpress # 修改完 yaml 檔案套用 helm upgrade wordpress # 可倒退版本 helm rollback wordpress # 移除 wordpress helm uninstall wordpress # debug 資訊 helm --debug Helm2 vs Helm3 Helm3 多了</description></item><item><title>kind</title><link>https://blog.yakushou.com/posts/k8s/kind/</link><pubDate>Mon, 03 Jan 2022 11:55:15 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/k8s/kind/</guid><description>kind official page
kind 可以用來在 local 建立 k8s cluster
# 安裝 kind brew install kind # 建立 cluster kind create cluster # 查看 clusters kind get clusters # 查看 kind 的 kubeconfig kind get kubeconfig # 切換到 kind cluster kubectl config use-context kind-kind # 查看 cluster 狀態 kubectl cluster-info</description></item><item><title>gitops</title><link>https://blog.yakushou.com/posts/devops/gitops/</link><pubDate>Sun, 02 Jan 2022 22:41:12 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/devops/gitops/</guid><description>What is GitOps 為了避免手動 deploy 而提出的解決方案
Infrastructure as Code 提倡後，大家會把 infrastructure 寫成 code 以後管控
但是針對變更 infrastructure 仍然後是在本機安裝工具後手動變更 (ex: ansible / terraform&amp;hellip;)
GitOps 提倡一切 (infrastructure/network/policy/configuration/security&amp;hellip;) 都以 YAML 的形式放在 git 上，並且透過 PR 自動更新資源
GitOps flow Create Pull/Merge Request 任何人都可以發 PR，大家可以 review Run CI pipeline 驗證 configuration files 跑自動化測試 Approve Changes 到這步代表 code 是經過測試以及 well reviewed Run CD Pipeline merge 回 main 以後觸發 CD pipeline 部署到 aws/k8s&amp;hellip;等等 優點:</description></item><item><title>flux</title><link>https://blog.yakushou.com/posts/devops/flux/</link><pubDate>Sun, 02 Jan 2022 21:49:17 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/devops/flux/</guid><description>目前看起來像是 K8S 的 CD 工具
Flux 是什麼? Flux 是一組用於 k8s 的 delivery solution
Flux 提供 GitOps for apps 和 infrastructure Flux 和 Flagger 提供 canaries/feature flags/AB rollouts 來部署 app 可用來管理 k8s 資源 推 git 以後，剩下的 Flux 會處理 可套用 CD (by Flagger) 和 PD (progressive delivery) container image 發生更新後，Flux 可以自動推 git Flux 相容現有的工具 含 github/gitlab/bitbucket/s3&amp;hellip;，以及全部有提供 cli 的 provider Flux 可用於任何 k8s 和所有常見的 k8s 工具 Kustomize/Helm/RBAC&amp;hellip;等等 Flux 處理 multi-everything 可以處理多數個 cluster Flux 有告警和提示 只要 git push，可以得到通知 使用者信任 Flux Flux 是 CNCF 孵化出的專案 Flux 有友善的社群 任何人都可以貢獻 Flux 是一組 k8s 用的工具，可以 sync 資源設定 (像 git repository)</description></item></channel></rss>