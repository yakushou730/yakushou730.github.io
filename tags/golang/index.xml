<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>golang - Tag - YakuShou's NOTEBOOK</title><link>https://blog.yakushou.com/tags/golang/</link><description>golang - Tag - YakuShou's NOTEBOOK</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 23 Nov 2021 18:26:55 +0800</lastBuildDate><atom:link href="https://blog.yakushou.com/tags/golang/" rel="self" type="application/rss+xml"/><item><title>errors</title><link>https://blog.yakushou.com/posts/golang/packages/errors/</link><pubDate>Tue, 23 Nov 2021 18:26:55 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/packages/errors/</guid><description>#As func As(err error, target interface{}) bool
第一個參數是現在拿到的 error
會透過呼叫 Unwrap 來比對 err 的第一個錯誤是否和 target 相同 如果對的話，會把 target 設定為 err 並回傳 true 否則回傳 false
範例
err := dec.Decode(dst) if err != nil { var syntaxError *json.SyntaxError switch { case errors.As(err, &amp;amp;syntaxError): return fmt.Errorf(&amp;#34;body contains badly-formed JSON (at character %d)&amp;#34;, syntaxError.Offset) default: return err } } #Is func Is(err error, target error) bool
第一個參數是現在拿到的 error 第二個參數是想要比對的特定 error
比對方式是透過呼叫 Unwrap 逐一拆解來比對是否包含 特定的 error</description></item><item><title>json</title><link>https://blog.yakushou.com/posts/golang/packages/json/</link><pubDate>Tue, 23 Nov 2021 17:08:07 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/packages/json/</guid><description><![CDATA[tag 標記用法 範例 json:&quot;name,omitempty&quot;
這個欄位名稱為 name，如果欄位內容是空值的話，則欄位會被忽略
範例 json:&quot;-&quot; 不管欄位名稱是什麼，都會忽略不印出
omitempty 這個欄位 如果是結構的話
無論是否為空值，一定會產生出欄位，值為空
例如
s := struct { Foo struct { Bar string `json:&#34;,omitempty&#34;` } `json:&#34;,omitempty&#34;` }{} // encoding result {&#34;Foo&#34;:{}} 解決辦法是透過指標的方式
例如
s := struct { Foo *struct { Bar string `json:&#34;,omitempty&#34;` } `json:&#34;,omitempty&#34;` }{} // encoding result {} 此外如果欄位型態是 time.Time 的話
omitempty 不會運作
escaped json 編碼的時候如果碰到 &gt; &lt; &amp;
會轉為逃逸字元
範例
s := []string{ &#34;&lt;foo&gt;&#34;, &#34;bar &amp; baz&#34;, } // result [&#34;\u003cfoo\u003e&#34;,&#34;bar \u0026 baz&#34;] 如果要避免的話，要在 json.]]></description></item><item><title>golang-migrate</title><link>https://blog.yakushou.com/posts/golang/packages/golang-migrate/</link><pubDate>Sun, 21 Nov 2021 23:36:24 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/packages/golang-migrate/</guid><description>github link
以 postgreSQL 為例
安裝 (用 homebrew) $ brew install golang-migrate 確認版本 $ migrate -version 建立 migration 檔案 # 建立 migration 檔案 $ migrate create -seq -ext=.sql -dir=./migrations create_movies_table -sql : 用數字序列的方式命名 migration 檔案 (如0001, 0002, &amp;hellip;) 預設是用 unix timestamp -ext : 指定 migration 檔案的 extension 名稱 -dir : 表示我們要把 migration 檔案建立在哪個路徑 (若路徑不存在的話會自動建立) create_movies_table 是想要建立的檔案名稱 接著系統會建立兩份 migration 檔案 000001_create_movies_table.down.sql 000001_create_movies_table.up.sql
之後便可在這兩份檔案寫入對應的 SQL 語法
執行 migrate (up) $ export GREENLIGHT_DB_DSN=&amp;#39;postgres://greenlight:@localhost/greenlight?</description></item><item><title>Signal</title><link>https://blog.yakushou.com/posts/golang/signal/</link><pubDate>Sat, 20 Nov 2021 23:24:11 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/signal/</guid><description>Signal 類型 Signal Description Keyboard Shortcut Catchable SIGINT 鍵盤中斷訊號 Ctrl + C true SIGQUIT 鍵盤離開訊號 Ctrl + |true SIGKILL 刪除程序(立即終止) - no SIGTERM 照順序終止程序 - true kill pid 會傳送SIGTERM到程序pid
shutdown() shutdown 的關閉流程不會中斷任何作用中的連線
先關閉所有 open 的 listener 再關閉所有 idle 的 listener 等候作用中連線成為 idle shutdown http.Server 的 Shutdown 會在結束時回傳錯誤碼 (沒錯誤的話回傳 nil)</description></item><item><title>Slice</title><link>https://blog.yakushou.com/posts/golang/slice/</link><pubDate>Tue, 16 Nov 2021 22:59:16 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/slice/</guid><description>建立空的 Slice var movies []*Movie movie = &amp;amp;Movie{} // 這樣子建立出來的 movies slice 是 nil // 但已經足夠用來做 append // 不需要寫成 movies := []*Movie{} movies = append(movies, movie) 把 array 轉成 slice // hash 是 [32]byte 的 byte array hash := sha256.Sum256(info) // b.Hash 是 byte slice b.Hash = hash[:]</description></item><item><title>Useful Golang Site</title><link>https://blog.yakushou.com/posts/site/useful-golang-site/</link><pubDate>Fri, 12 Nov 2021 15:46:11 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/site/useful-golang-site/</guid><description>Golang Developer Roadmap
Go Patterns
Code Review Comments
Go Best Practices
Golang Open Source Projects
Calhoun&amp;rsquo;s Golang Blog
小惡魔 - ApplyBOY
KKDAI.GITHUB.IO
Applied Go
OPENHOME
Kenny&amp;rsquo;s Blog
segmentfault Golang 攻略
ALEX EDWARDS
PJCHENder
GO 語言書推薦
Welcome To Golang By Example
Go的50度灰：Golang新开发者要注意的陷阱和常见错误
GoBooks
Programming Percy
Three Dots Labs
Spaceship Go
Webapps in Go
Steven Victor
LeetCode Cookbook
Go 技巧 101
Practical Go Lessons
Learn Go with Tests
Ompluscator Blog
鳥窩
Intermediate Go</description></item></channel></rss>