<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>programming - Tag - YakuShou's NOTEBOOK</title><link>https://blog.yakushou.com/tags/programming/</link><description>programming - Tag - YakuShou's NOTEBOOK</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 28 Dec 2021 19:02:38 +0800</lastBuildDate><atom:link href="https://blog.yakushou.com/tags/programming/" rel="self" type="application/rss+xml"/><item><title>YAML Files</title><link>https://blog.yakushou.com/posts/k8s/yaml-files/</link><pubDate>Tue, 28 Dec 2021 19:02:38 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/k8s/yaml-files/</guid><description>General YAML template 必要的 4 個欄位
apiVersion:# 要用來建立物件的 k8s API 版本 kind:# 要建立的物件metadata:# 物件的其他資訊，如 name, labels...spec:# 建立物件需要的訊息 apiVersion (string) POD: v1 Service: v1 ReplicaSet: apps/v1 Deployment: apps/v1 kind (string) Pod Service ReplicaSet Deployment metadata (dictionary) name labels labels 下的 key/value 值是可以自訂的 spec (dictionary) 指令:
# 可以看介紹 kubectl explain &amp;lt;k8s kind&amp;gt; POD with YAML pod-definition.yaml
apiVersion:v1kind:Podmetadata:name:myapp-podlabels:app:myapptype:front-endspec:containers:- name:nginx-containerimage:nginx指令
# 建立 kubectl create -f pod-definition.</description></item><item><title>concepts</title><link>https://blog.yakushou.com/posts/k8s/concepts/</link><pubDate>Tue, 28 Dec 2021 14:35:13 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/k8s/concepts/</guid><description>概念 Container + Orchestration
k8s 是一種容器編排技術，用於協調數百個對象的部署和管理 cluster 中的數千個容器
VM vs Docker VM 是在 原本的 OS 上，再額外起來的完整的虛擬機器，具有完整的虛擬 OS 每個 VM 裡面除了 OS 外還有各自的 libs 和 deps 動輒以 GB 為單位 啟動速度慢 Docker 是基於原本的內核，起起來的 container libs 和 deps 在各自容器內 大約以 MB 為單位 啟動速度快 術語 node (minion) 安裝了 k8s 的機器，container 會起在這上面 cluster 一組複數個 nodes ( 1 個 master / 多個 worker) 會有一台 master node，負責監管和負責流程編排 node 上 的 container components 安裝 k8s 時，會安裝的一些元件 API server 可以作為 k8s 的前端 etcd key-value store 確保 master 間沒有 conflict kubelet 每個 node 都會安裝的 agent 確保 container 可以運作在 node 上 container runtime 用來跑 container 的環境 (ex: Docker) controller orchestration 的大腦，在 nodes / containers 發生故障時發出通知和回應 決定是否建立新的 container scheduler 分配 container 給 nodes master 上 會安裝 kube-apiserver 會安裝 etcd 儲存資訊 會安裝 controller 會安裝 scheduler worker 上 會安裝 kubelet 和 master 溝通</description></item><item><title>software</title><link>https://blog.yakushou.com/posts/programming/software/</link><pubDate>Mon, 27 Dec 2021 18:04:23 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/programming/software/</guid><description>Declarative vs imperative language Declarative programming (宣告式)
What 代表為 functional programming (function 之間不會互相共用狀態) 程式碼通常是可以直接看到在做什麼 (重視 what) Imperative programming (命令式)
how to do 代表為 OOP (狀態互相依賴) 看得見邏輯運算過程 (how to do)</description></item><item><title>fundamental</title><link>https://blog.yakushou.com/posts/golang/fundamental/</link><pubDate>Mon, 27 Dec 2021 16:10:27 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/fundamental/</guid><description><![CDATA[如何在 go get 的時候可以拉到 private repo 概念:
因為是 private repo 的關係， 所以要讓 go 有權限去拉
拉的時候是透過 git，所以要設定具有權限的 token 給 git
 在個人的 github settings 建立一個可以拉取 private repo 的 token 把 token 記下以後，在本機操作 git cli 用 copy 下來的 token 取代下列的 GITHUB_TOKEN  $ git config --global url.&#34;https://${GITHUB_TOKEN}@github.com&#34;.insteadOf &#34;https://github.com&#34; ]]></description></item><item><title>basic for beginner</title><link>https://blog.yakushou.com/posts/k8s/basic-for-beginner/</link><pubDate>Fri, 24 Dec 2021 11:28:29 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/k8s/basic-for-beginner/</guid><description><![CDATA[從 AWS EKS 下載 k8s config 範例:
aws eks --region ap-southeast-1 update-kubeconfig --name &lt;cluster-name&gt; --kubeconfig &lt;the name that we download to local&gt; 載下來的 kube config 如何載入 載下來的 config 可以放到 ~/.kube 內
然後在 bash profile 設定環境變數 KUBECONFIG
# k8s config setting export KUBECONFIG=~/.kube/service-prod-config:\ ~/.kube/service-staging-config 使用 context # 取得 context list  kubectl config get-contexts # 使用特定 context kubectl config use-context &lt;context name&gt; # 詢問當前 context kubectl config current-context 使用 kubectx 可快速切換 k8s context 的工具]]></description></item><item><title>Makefile</title><link>https://blog.yakushou.com/posts/programming/makefile/</link><pubDate>Sun, 05 Dec 2021 21:01:05 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/programming/makefile/</guid><description><![CDATA[範例
GREENLIGHT_DB_DSN=&#39;postgres://greenlight:@localhost/greenlight?sslmode=disable&#39; ## help: print this help message .PHONY: help help: @echo &#39;Usage:&#39; @sed -n &#39;s/^##//p&#39; ${MAKEFILE_LIST} | column -t -s &#39;:&#39; | sed -e &#39;s/^/ /&#39; .PHONY: confirm confirm: @echo &#39;Are you sure? [y/N] &#39; &amp;&amp; read ans &amp;&amp; [ $${ans:-N} = y ] ## run/api: run the cmd/api application .PHONY: run/api run/api: go run ./cmd/api ## db/psql: connect to the database using psql .PHONY: db/psql db/psql: psql ${GREENLIGHT_DB_DSN} ## db/migrations/new name=$1: create a new database migration .]]></description></item><item><title>script</title><link>https://blog.yakushou.com/posts/programming/script/</link><pubDate>Mon, 29 Nov 2021 22:01:31 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/programming/script/</guid><description>範例 script.sh
$ touch script.sh $ chmod +x script.sh 檔案內容
#!/bin/zsh GREENLIGHT_DB_DSN=&amp;#39;postgres://greenlight:@localhost/greenlight?sslmode=disable&amp;#39; echo ${GREENLIGHT_DB_DSN} 運行 script.sh
$ ./script.sh Reference 簡明 Linux Shell Script 入門教學</description></item><item><title>Signal</title><link>https://blog.yakushou.com/posts/golang/signal/</link><pubDate>Sat, 20 Nov 2021 23:24:11 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/signal/</guid><description>Signal 類型 Signal Description Keyboard Shortcut Catchable SIGINT 鍵盤中斷訊號 Ctrl + C true SIGQUIT 鍵盤離開訊號 Ctrl + |true SIGKILL 刪除程序(立即終止) - no SIGTERM 照順序終止程序 - true kill pid 會傳送SIGTERM到程序pid
shutdown() shutdown 的關閉流程不會中斷任何作用中的連線
先關閉所有 open 的 listener 再關閉所有 idle 的 listener 等候作用中連線成為 idle shutdown http.Server 的 Shutdown 會在結束時回傳錯誤碼 (沒錯誤的話回傳 nil)</description></item><item><title>Web Development</title><link>https://blog.yakushou.com/posts/programming/web-development/</link><pubDate>Wed, 17 Nov 2021 16:45:33 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/programming/web-development/</guid><description>web url encoding 在 url 內的 + 代表空白，也可以用 %20 表示 user enumeration 一種可能的帳號攻擊行為
比如說嘗試使用者登入，輸入email 和 密碼
系統顯示 密碼錯誤 而不是 帳號密碼錯誤 或 找不到此使用者
代表這個使用者的 email 信箱是存在且有註冊過這個網站的
即使用者的資訊被其他人知曉
要避免的話，可以統一錯誤訊息或是把錯誤訊息寫得更通用一點
CORS cross-origin requests
origin: 如果兩個 URL 的 scheme, host, port 都相同，
即為相同 origin
(path 不需要相同)
https://foo.com:443/a/
https 是 scheme foo.com 是 host 443 是 port a 是 path web browser 預設是禁止的 網站可以內嵌其他 origin 的資源 一個網站可以傳送資料給不同的 origin 位址 但是一個網站不能夠接收來自不同 origin 的資料 (瀏覽器行為) 可以透過設定 Header 內的 Access-Control 來控制允許或不允洗特定的 cross-origin requests 打我們的 API 藍覽器以外的工具，如 curl, wget 不會受到影響 如果在 API 的 response header 的 Header 的 Access-Control-Allow-Origin 塞值 *</description></item><item><title>Slice</title><link>https://blog.yakushou.com/posts/golang/slice/</link><pubDate>Tue, 16 Nov 2021 22:59:16 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/slice/</guid><description>建立空的 Slice var movies []*Movie movie = &amp;amp;Movie{} // 這樣子建立出來的 movies slice 是 nil // 但已經足夠用來做 append // 不需要寫成 movies := []*Movie{} movies = append(movies, movie) 把 array 轉成 slice // hash 是 [32]byte 的 byte array hash := sha256.Sum256(info) // b.Hash 是 byte slice b.Hash = hash[:]</description></item></channel></rss>