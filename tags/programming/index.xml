<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>programming - Tag - YakuShou's NOTEBOOK</title><link>https://blog.yakushou.com/tags/programming/</link><description>programming - Tag - YakuShou's NOTEBOOK</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 02 Jan 2022 09:35:24 +0800</lastBuildDate><atom:link href="https://blog.yakushou.com/tags/programming/" rel="self" type="application/rss+xml"/><item><title>git</title><link>https://blog.yakushou.com/posts/programming/git/</link><pubDate>Sun, 02 Jan 2022 09:35:24 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/programming/git/</guid><description>git</description></item><item><title>basics</title><link>https://blog.yakushou.com/posts/devops/basics/</link><pubDate>Sun, 02 Jan 2022 09:27:51 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/devops/basics/</guid><description>Environment variable SHELL: 系統使用了哪種 shell 確認 OS Version # 印出所有 release 版本 ls /etc/*release* # 印出當前版本細節 cat /etc/*release*</description></item><item><title>YAML Files</title><link>https://blog.yakushou.com/posts/k8s/yaml-files/</link><pubDate>Tue, 28 Dec 2021 19:02:38 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/k8s/yaml-files/</guid><description>General YAML template 必要的 4 個欄位
apiVersion:# 要用來建立物件的 k8s API 版本 kind:# 要建立的物件metadata:# 物件的其他資訊，如 name, labels...spec:# 建立物件需要的訊息 apiVersion (string) POD: v1 Service: v1 ReplicaSet: apps/v1 Deployment: apps/v1 kind (string) Pod Service ReplicaSet Deployment metadata (dictionary) name labels labels 下的 key/value 值是可以自訂的 spec (dictionary) 指令:
# 可以看介紹 kubectl explain &amp;lt;k8s kind&amp;gt; POD with YAML pod-definition.yaml
apiVersion:v1kind:Podmetadata:name:myapp-podlabels:app:myapptype:front-endspec:containers:- name:nginx-containerimage:nginx指令
# 建立 kubectl create -f pod-definition.</description></item><item><title>concepts</title><link>https://blog.yakushou.com/posts/k8s/concepts/</link><pubDate>Tue, 28 Dec 2021 14:35:13 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/k8s/concepts/</guid><description>概念 Container + Orchestration
k8s 是一種容器編排技術，用於協調數百個對象的部署和管理 cluster 中的數千個容器
VM vs Docker VM 是在 原本的 OS 上，再額外起來的完整的虛擬機器，具有完整的虛擬 OS 每個 VM 裡面除了 OS 外還有各自的 libs 和 deps 動輒以 GB 為單位 啟動速度慢 Docker 是基於原本的內核，起起來的 container libs 和 deps 在各自容器內 大約以 MB 為單位 啟動速度快 術語 node (minion) 安裝了 k8s 的機器，container 會起在這上面 cluster 一組複數個 nodes ( 1 個 master / 多個 worker) 會有一台 master node，負責監管和負責流程編排 node 上 的 container components 安裝 k8s 時，會安裝的一些元件 API server 可以作為 k8s 的前端 etcd key-value store 確保 master 間沒有 conflict kubelet 每個 node 都會安裝的 agent 確保 container 可以運作在 node 上 container runtime 用來跑 container 的環境 (ex: Docker) controller orchestration 的大腦，在 nodes / containers 發生故障時發出通知和回應 決定是否建立新的 container scheduler 分配 container 給 nodes master 上 會安裝 kube-apiserver 會安裝 etcd 儲存資訊 會安裝 controller 會安裝 scheduler worker 上 會安裝 kubelet 和 master 溝通</description></item><item><title>software</title><link>https://blog.yakushou.com/posts/programming/software/</link><pubDate>Mon, 27 Dec 2021 18:04:23 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/programming/software/</guid><description>Declarative vs imperative language Declarative programming (宣告式)
What 代表為 functional programming (function 之間不會互相共用狀態) 程式碼通常是可以直接看到在做什麼 (重視 what) Imperative programming (命令式)
how to do 代表為 OOP (狀態互相依賴) 看得見邏輯運算過程 (how to do) Repository Pattern Repository Pattern 是在 domain 和 data mapping 的中間層
透過 collection-like 的 interface 來存取 domain object
換句話說可以是 application 和 data access logic 的中間層
好處:
修改邏輯的時候只要改一個地方 測試 controller 變簡單了，不用真實存取資料庫資料 舉例: EmployeeController -&amp;gt; Employee Repository -&amp;gt; SQL server Database</description></item><item><title>fundamental</title><link>https://blog.yakushou.com/posts/golang/fundamental/</link><pubDate>Mon, 27 Dec 2021 16:10:27 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/fundamental/</guid><description><![CDATA[如何在 go get 的時候可以拉到 private repo 概念:
因為是 private repo 的關係， 所以要讓 go 有權限去拉
拉的時候是透過 git，所以要設定具有權限的 token 給 git
 在個人的 github settings 建立一個可以拉取 private repo 的 token 把 token 記下以後，在本機操作 git cli 用 copy 下來的 token 取代下列的 GITHUB_TOKEN  $ git config --global url.&#34;https://${GITHUB_TOKEN}@github.com&#34;.insteadOf &#34;https://github.com&#34; ]]></description></item><item><title>basic for beginner</title><link>https://blog.yakushou.com/posts/k8s/basic-for-beginner/</link><pubDate>Fri, 24 Dec 2021 11:28:29 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/k8s/basic-for-beginner/</guid><description><![CDATA[從 AWS EKS 下載 k8s config 範例:
aws eks --region ap-southeast-1 update-kubeconfig --name &lt;cluster-name&gt; --kubeconfig &lt;the name that we download to local&gt; 載下來的 kube config 如何載入 載下來的 config 可以放到 ~/.kube 內
然後在 bash profile 設定環境變數 KUBECONFIG
# k8s config setting export KUBECONFIG=~/.kube/service-prod-config:\ ~/.kube/service-staging-config 使用 context # 取得 context list  kubectl config get-contexts # 使用特定 context kubectl config use-context &lt;context name&gt; # 詢問當前 context kubectl config current-context 使用 kubectx 可快速切換 k8s context 的工具]]></description></item><item><title>Makefile</title><link>https://blog.yakushou.com/posts/programming/makefile/</link><pubDate>Sun, 05 Dec 2021 21:01:05 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/programming/makefile/</guid><description><![CDATA[範例
GREENLIGHT_DB_DSN=&#39;postgres://greenlight:@localhost/greenlight?sslmode=disable&#39; ## help: print this help message .PHONY: help help: @echo &#39;Usage:&#39; @sed -n &#39;s/^##//p&#39; ${MAKEFILE_LIST} | column -t -s &#39;:&#39; | sed -e &#39;s/^/ /&#39; .PHONY: confirm confirm: @echo &#39;Are you sure? [y/N] &#39; &amp;&amp; read ans &amp;&amp; [ $${ans:-N} = y ] ## run/api: run the cmd/api application .PHONY: run/api run/api: go run ./cmd/api ## db/psql: connect to the database using psql .PHONY: db/psql db/psql: psql ${GREENLIGHT_DB_DSN} ## db/migrations/new name=$1: create a new database migration .]]></description></item><item><title>script</title><link>https://blog.yakushou.com/posts/programming/script/</link><pubDate>Mon, 29 Nov 2021 22:01:31 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/programming/script/</guid><description>範例 script.sh
$ touch script.sh $ chmod +x script.sh 檔案內容
#!/bin/zsh GREENLIGHT_DB_DSN=&amp;#39;postgres://greenlight:@localhost/greenlight?sslmode=disable&amp;#39; echo ${GREENLIGHT_DB_DSN} 運行 script.sh
$ ./script.sh Reference 簡明 Linux Shell Script 入門教學</description></item><item><title>Signal</title><link>https://blog.yakushou.com/posts/golang/signal/</link><pubDate>Sat, 20 Nov 2021 23:24:11 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/signal/</guid><description>Signal 類型 Signal Description Keyboard Shortcut Catchable SIGINT 鍵盤中斷訊號 Ctrl + C true SIGQUIT 鍵盤離開訊號 Ctrl + |true SIGKILL 刪除程序(立即終止) - no SIGTERM 照順序終止程序 - true kill pid 會傳送SIGTERM到程序pid
shutdown() shutdown 的關閉流程不會中斷任何作用中的連線
先關閉所有 open 的 listener 再關閉所有 idle 的 listener 等候作用中連線成為 idle shutdown http.Server 的 Shutdown 會在結束時回傳錯誤碼 (沒錯誤的話回傳 nil)</description></item></channel></rss>