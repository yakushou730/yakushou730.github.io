<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>YakuShou's NOTEBOOK</title><link>https://blog.yakushou.com/</link><description>YakuShou's NOTEBOOK</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 24 Dec 2021 11:28:29 +0800</lastBuildDate><atom:link href="https://blog.yakushou.com/index.xml" rel="self" type="application/rss+xml"/><item><title>temporary</title><link>https://blog.yakushou.com/posts/k8s/temporary/</link><pubDate>Fri, 24 Dec 2021 11:28:29 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/k8s/temporary/</guid><description><![CDATA[從 AWS EKS 下載 k8s config 範例:
aws eks --region ap-southeast-1 update-kubeconfig --name &lt;cluster-name&gt; --kubeconfig &lt;the name that we download to local&gt; 載下來的 kube config 如何載入 載下來的 config 可以放到 ~/.kube 內
然後在 bash profile 設定環境變數 KUBECONFIG
# k8s config setting export KUBECONFIG=~/.kube/service-prod-config:\ ~/.kube/service-staging-config 使用 context # 取得 context list  kubectl config get-contexts # 使用特定 context kubectl config use-context &lt;context name&gt; # 詢問當前 context kubectl config current-context 使用 kubectx 可快速切換 k8s context 的工具]]></description></item><item><title>mapping and analysis</title><link>https://blog.yakushou.com/posts/udemy/complete-guide-to-elasticsearch/mapping-and-analysis/</link><pubDate>Fri, 17 Dec 2021 01:19:57 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/udemy/complete-guide-to-elasticsearch/mapping-and-analysis/</guid><description><![CDATA[Introduction to analysis  _source object 是做 index document 但卻不是用來作為搜尋的內容欄位 分析字串:  analyzer  character filter tokenizer token filter 舉例 (filter 和 tokenizer 種類繁多，僅舉例簡單情境):   分析 I REALLY like beer!  character filter 做成 I REALLY Like beer! Tokenizer 做成 [&quot;I&quot;, &quot;REALLY&quot;, &quot;Like&quot;, &quot;beer&quot;] Token Filter 做成 [&quot;i&quot;, &quot;really&quot;, &quot;like&quot;, &quot;beer&quot;]     儲存的字串會被切成較小的字串儲存 (Tokenizer)  Using the Analyze API POST /_analyze { &quot;text&quot;: &quot;2 guys walk into a bar, but the third.]]></description></item><item><title>managing documents</title><link>https://blog.yakushou.com/posts/udemy/complete-guide-to-elasticsearch/managing-documtents/</link><pubDate>Wed, 15 Dec 2021 22:57:51 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/udemy/complete-guide-to-elasticsearch/managing-documtents/</guid><description><![CDATA[Creating &amp; deleting indices 新增 index
範例: 新增 products index
PUT /products # 結果 { &quot;acknowledged&quot; : true, &quot;shards_acknowledged&quot; : true, &quot;index&quot; : &quot;products&quot; }  acknowledged: 表示是否有執行成功 shards_acknowledged: 表示 required shards 是否有在 timeout 前 start up  default 是指 primary shard    刪除 index
範例: 刪除 products index
DELETE /products Indexing documents 插入資料: index a document
POST /products/_doc { &quot;name&quot;: &quot;Coffee Maker&quot;, &quot;price&quot;: 64, &quot;in_stock&quot;: 10 } # result { &quot;_index&quot; : &quot;products&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;ek25vn0BLyjHJvg3PVzk&quot;, &quot;_version&quot; : 1, &quot;result&quot; : &quot;created&quot;, &quot;_shards&quot; : { &quot;total&quot; : 2, &quot;successful&quot; : 1, &quot;failed&quot; : 0 }, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1 } _shards: 表示有多少 shards 成功/失敗 儲存這筆資料 _id: 表示這筆資料的 identifier (系統自動產生，或者也可以自己指定)]]></description></item><item><title>getting started</title><link>https://blog.yakushou.com/posts/udemy/complete-guide-to-elasticsearch/getting-started/</link><pubDate>Tue, 14 Dec 2021 10:38:32 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/udemy/complete-guide-to-elasticsearch/getting-started/</guid><description>Installation 安裝 Elasticsearch 安裝後可以用 http://localhost:9200 確認服務是否正常 Elasticsearch 的檔案目錄 bin 放置執行檔 (Elasticsearch 以外的還有如 plugin 安裝檔 或 cli) config 放置 configuration file elasticsearch.yml 檔案內容是 comment 標起來的，如果不另外把 comment 拿掉的話，系統會使用預設值
best practice 是要註明 cluster.name 和 node.name
data / log 的路徑最好也自行指定 (特別指在 production 上)
這樣即使砍了 Elasticsearch 也不會有資料遺失
jvm.options
用來調整系統的記憶體配置 log4j2.properties
寫 log 的 framework data jdk 包含 OpenJDK lib 包含 Elasticsearch 會用到的 dependency logs modules 包含很多內建的 module plugins Basic architecture 基礎單元是 node，是 Elasticsearch 的 instance，用來儲存 data node 可以執行複數個，各自儲存部分的資料 node 不是機器，所以可以用幾台機器運行更多個 node 每個 node 都隸屬在 cluster 下 cluster 包含 nodes 通常不同的 cluster 會用來做不同的搜尋情境，彼此獨立 資料單位稱為 document，是一筆 json 格式的資料 index a document，意思是送一筆 json object 給 Elasticsearch 該筆 json object 到 Elasticsearch 後會在 &amp;quot;_source&amp;quot; 的節點下，並賦予其他 meta data index 包含多個 document query 的時候，是對指定的 index 做搜尋 document Kibana console 進入 Kibana 介面，並點擊 Dev Tools query HTTP method + request path 範例: 取得 cluster 狀態</description></item><item><title>introduction</title><link>https://blog.yakushou.com/posts/udemy/complete-guide-to-elasticsearch/introduction/</link><pubDate>Tue, 14 Dec 2021 01:13:54 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/udemy/complete-guide-to-elasticsearch/introduction/</guid><description>Introduction to Elasticsearch 儲存一筆資料的單位是 document (類似 RDB 的 row) Document 的欄位叫做 fields (類似 RDB 的 column) 儲存的格式像 json client 透過 REST API 和 Elasticsearch 溝通 Overview of the Elastic Stack Kibana 分析 / 視覺畫的平台 透過 Elasticsearch 的資料來做視覺化 (發 http request) Logstash 處理 log (或其他資料，如訂單) 後把資料送給 Elasticsearch (也可以傳給不同的對象，如 Kafka) 資料處理的 pipeline pipeline 三步驟: input filter output pipeline configuration 的格式像 json X-Pack 提供額外功能給 Elasticsearch 和 Kibana Security authentication authorization Monitoring 視覺化 Elastic Stack 如何運作 (如顯示 CPU / memory usage / disk space) Alerting 設定告警 (如透過 email 通知) Reporting 輸出 Kibana 的資料 Machine Learning enable machine learning for Elasticsearch &amp;amp; Kibana Graph 分析資料的關聯 Elasticsearch SQL 可以傳送 SQL query 給 Elasticsearch Beats 蒐集資料並運送 Walkthrough of common architectures 同時儲存資料在 DB 和 Elasticsearch，後端收到 request 的時候兩邊都做 query</description></item><item><title>Makefile</title><link>https://blog.yakushou.com/posts/programming/makefile/</link><pubDate>Sun, 05 Dec 2021 21:01:05 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/programming/makefile/</guid><description><![CDATA[範例
GREENLIGHT_DB_DSN=&#39;postgres://greenlight:@localhost/greenlight?sslmode=disable&#39; ## help: print this help message .PHONY: help help: @echo &#39;Usage:&#39; @sed -n &#39;s/^##//p&#39; ${MAKEFILE_LIST} | column -t -s &#39;:&#39; | sed -e &#39;s/^/ /&#39; .PHONY: confirm confirm: @echo &#39;Are you sure? [y/N] &#39; &amp;&amp; read ans &amp;&amp; [ $${ans:-N} = y ] ## run/api: run the cmd/api application .PHONY: run/api run/api: go run ./cmd/api ## db/psql: connect to the database using psql .PHONY: db/psql db/psql: psql ${GREENLIGHT_DB_DSN} ## db/migrations/new name=$1: create a new database migration .]]></description></item><item><title>script</title><link>https://blog.yakushou.com/posts/programming/script/</link><pubDate>Mon, 29 Nov 2021 22:01:31 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/programming/script/</guid><description>範例 script.sh
$ touch script.sh $ chmod +x script.sh 檔案內容
#!/bin/zsh GREENLIGHT_DB_DSN=&amp;#39;postgres://greenlight:@localhost/greenlight?sslmode=disable&amp;#39; echo ${GREENLIGHT_DB_DSN} 運行 script.sh
$ ./script.sh Reference 簡明 Linux Shell Script 入門教學</description></item><item><title>Useful Design Site</title><link>https://blog.yakushou.com/posts/site/useful-design-site/</link><pubDate>Fri, 26 Nov 2021 07:36:16 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/site/useful-design-site/</guid><description>infograpify</description></item><item><title>errors</title><link>https://blog.yakushou.com/posts/golang/packages/errors/</link><pubDate>Tue, 23 Nov 2021 18:26:55 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/packages/errors/</guid><description>#As func As(err error, target interface{}) bool
第一個參數是現在拿到的 error
會透過呼叫 Unwrap 來比對 err 的第一個錯誤是否和 target 相同 如果對的話，會把 target 設定為 err 並回傳 true 否則回傳 false
範例
err := dec.Decode(dst) if err != nil { var syntaxError *json.SyntaxError switch { case errors.As(err, &amp;amp;syntaxError): return fmt.Errorf(&amp;#34;body contains badly-formed JSON (at character %d)&amp;#34;, syntaxError.Offset) default: return err } } #Is func Is(err error, target error) bool
第一個參數是現在拿到的 error 第二個參數是想要比對的特定 error
比對方式是透過呼叫 Unwrap 逐一拆解來比對是否包含 特定的 error</description></item><item><title>json</title><link>https://blog.yakushou.com/posts/golang/packages/json/</link><pubDate>Tue, 23 Nov 2021 17:08:07 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/packages/json/</guid><description><![CDATA[tag 標記用法 範例 json:&quot;name,omitempty&quot;
這個欄位名稱為 name，如果欄位內容是空值的話，則欄位會被忽略
範例 json:&quot;-&quot; 不管欄位名稱是什麼，都會忽略不印出
omitempty 這個欄位 如果是結構的話
無論是否為空值，一定會產生出欄位，值為空
例如
s := struct { Foo struct { Bar string `json:&#34;,omitempty&#34;` } `json:&#34;,omitempty&#34;` }{} // encoding result {&#34;Foo&#34;:{}} 解決辦法是透過指標的方式
例如
s := struct { Foo *struct { Bar string `json:&#34;,omitempty&#34;` } `json:&#34;,omitempty&#34;` }{} // encoding result {} 此外如果欄位型態是 time.Time 的話
omitempty 不會運作
escaped json 編碼的時候如果碰到 &gt; &lt; &amp;
會轉為逃逸字元
範例
s := []string{ &#34;&lt;foo&gt;&#34;, &#34;bar &amp; baz&#34;, } // result [&#34;\u003cfoo\u003e&#34;,&#34;bar \u0026 baz&#34;] 如果要避免的話，要在 json.]]></description></item></channel></rss>