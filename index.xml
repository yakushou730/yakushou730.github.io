<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>YakuShou's NOTEBOOK</title><link>https://blog.yakushou.com/</link><description>YakuShou's NOTEBOOK</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 28 Dec 2021 19:02:38 +0800</lastBuildDate><atom:link href="https://blog.yakushou.com/index.xml" rel="self" type="application/rss+xml"/><item><title>YAML Files</title><link>https://blog.yakushou.com/posts/k8s/yaml-files/</link><pubDate>Tue, 28 Dec 2021 19:02:38 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/k8s/yaml-files/</guid><description>General YAML template 必要的 4 個欄位
apiVersion:# 要用來建立物件的 k8s API 版本 kind:# 要建立的物件metadata:# 物件的其他資訊，如 name, labels...spec:# 建立物件需要的訊息 apiVersion (string) POD: v1 Service: v1 ReplicaSet: apps/v1 Deployment: apps/v1 kind (string) Pod Service ReplicaSet Deployment metadata (dictionary) name labels labels 下的 key/value 值是可以自訂的 spec (dictionary) 指令:
# 可以看介紹 kubectl explain &amp;lt;k8s kind&amp;gt; POD with YAML pod-definition.yaml
apiVersion:v1kind:Podmetadata:name:myapp-podlabels:app:myapptype:front-endspec:containers:- name:nginx-containerimage:nginx指令
# 建立 kubectl create -f pod-definition.</description></item><item><title>concepts</title><link>https://blog.yakushou.com/posts/k8s/concepts/</link><pubDate>Tue, 28 Dec 2021 14:35:13 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/k8s/concepts/</guid><description>概念 Container + Orchestration
k8s 是一種容器編排技術，用於協調數百個對象的部署和管理 cluster 中的數千個容器
VM vs Docker VM 是在 原本的 OS 上，再額外起來的完整的虛擬機器，具有完整的虛擬 OS 每個 VM 裡面除了 OS 外還有各自的 libs 和 deps 動輒以 GB 為單位 啟動速度慢 Docker 是基於原本的內核，起起來的 container libs 和 deps 在各自容器內 大約以 MB 為單位 啟動速度快 術語 node (minion) 安裝了 k8s 的機器，container 會起在這上面 cluster 一組複數個 nodes ( 1 個 master / 多個 worker) 會有一台 master node，負責監管和負責流程編排 node 上 的 container components 安裝 k8s 時，會安裝的一些元件 API server 可以作為 k8s 的前端 etcd key-value store 確保 master 間沒有 conflict kubelet 每個 node 都會安裝的 agent 確保 container 可以運作在 node 上 container runtime 用來跑 container 的環境 (ex: Docker) controller orchestration 的大腦，在 nodes / containers 發生故障時發出通知和回應 決定是否建立新的 container scheduler 分配 container 給 nodes master 上 會安裝 kube-apiserver 會安裝 etcd 儲存資訊 會安裝 controller 會安裝 scheduler worker 上 會安裝 kubelet 和 master 溝通</description></item><item><title>software</title><link>https://blog.yakushou.com/posts/programming/software/</link><pubDate>Mon, 27 Dec 2021 18:04:23 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/programming/software/</guid><description>Declarative vs imperative language Declarative programming (宣告式)
What 代表為 functional programming (function 之間不會互相共用狀態) 程式碼通常是可以直接看到在做什麼 (重視 what) Imperative programming (命令式)
how to do 代表為 OOP (狀態互相依賴) 看得見邏輯運算過程 (how to do)</description></item><item><title>fundamental</title><link>https://blog.yakushou.com/posts/golang/fundamental/</link><pubDate>Mon, 27 Dec 2021 16:10:27 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/fundamental/</guid><description><![CDATA[如何在 go get 的時候可以拉到 private repo 概念:
因為是 private repo 的關係， 所以要讓 go 有權限去拉
拉的時候是透過 git，所以要設定具有權限的 token 給 git
 在個人的 github settings 建立一個可以拉取 private repo 的 token 把 token 記下以後，在本機操作 git cli 用 copy 下來的 token 取代下列的 GITHUB_TOKEN  $ git config --global url.&#34;https://${GITHUB_TOKEN}@github.com&#34;.insteadOf &#34;https://github.com&#34; ]]></description></item><item><title>basic for beginner</title><link>https://blog.yakushou.com/posts/k8s/basic-for-beginner/</link><pubDate>Fri, 24 Dec 2021 11:28:29 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/k8s/basic-for-beginner/</guid><description><![CDATA[從 AWS EKS 下載 k8s config 範例:
aws eks --region ap-southeast-1 update-kubeconfig --name &lt;cluster-name&gt; --kubeconfig &lt;the name that we download to local&gt; 載下來的 kube config 如何載入 載下來的 config 可以放到 ~/.kube 內
然後在 bash profile 設定環境變數 KUBECONFIG
# k8s config setting export KUBECONFIG=~/.kube/service-prod-config:\ ~/.kube/service-staging-config 使用 context # 取得 context list  kubectl config get-contexts # 使用特定 context kubectl config use-context &lt;context name&gt; # 詢問當前 context kubectl config current-context 使用 kubectx 可快速切換 k8s context 的工具]]></description></item><item><title>mapping and analysis</title><link>https://blog.yakushou.com/posts/udemy/complete-guide-to-elasticsearch/mapping-and-analysis/</link><pubDate>Fri, 17 Dec 2021 01:19:57 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/udemy/complete-guide-to-elasticsearch/mapping-and-analysis/</guid><description><![CDATA[Introduction to analysis  _source object 是做 index document 但卻不是用來作為搜尋的內容欄位 分析字串:  analyzer  character filter tokenizer token filter 舉例 (filter 和 tokenizer 種類繁多，僅舉例簡單情境):   分析 I REALLY like beer!  character filter 做成 I REALLY Like beer! Tokenizer 做成 [&quot;I&quot;, &quot;REALLY&quot;, &quot;Like&quot;, &quot;beer&quot;] Token Filter 做成 [&quot;i&quot;, &quot;really&quot;, &quot;like&quot;, &quot;beer&quot;]     儲存的字串會被切成較小的字串儲存 (Tokenizer)  Using the Analyze API POST /_analyze { &quot;text&quot;: &quot;2 guys walk into a bar, but the third.]]></description></item><item><title>managing documents</title><link>https://blog.yakushou.com/posts/udemy/complete-guide-to-elasticsearch/managing-documtents/</link><pubDate>Wed, 15 Dec 2021 22:57:51 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/udemy/complete-guide-to-elasticsearch/managing-documtents/</guid><description><![CDATA[Creating &amp; deleting indices 新增 index
範例: 新增 products index
PUT /products # 結果 { &quot;acknowledged&quot; : true, &quot;shards_acknowledged&quot; : true, &quot;index&quot; : &quot;products&quot; }  acknowledged: 表示是否有執行成功 shards_acknowledged: 表示 required shards 是否有在 timeout 前 start up  default 是指 primary shard    刪除 index
範例: 刪除 products index
DELETE /products Indexing documents 插入資料: index a document
POST /products/_doc { &quot;name&quot;: &quot;Coffee Maker&quot;, &quot;price&quot;: 64, &quot;in_stock&quot;: 10 } # result { &quot;_index&quot; : &quot;products&quot;, &quot;_type&quot; : &quot;_doc&quot;, &quot;_id&quot; : &quot;ek25vn0BLyjHJvg3PVzk&quot;, &quot;_version&quot; : 1, &quot;result&quot; : &quot;created&quot;, &quot;_shards&quot; : { &quot;total&quot; : 2, &quot;successful&quot; : 1, &quot;failed&quot; : 0 }, &quot;_seq_no&quot; : 0, &quot;_primary_term&quot; : 1 } _shards: 表示有多少 shards 成功/失敗 儲存這筆資料 _id: 表示這筆資料的 identifier (系統自動產生，或者也可以自己指定)]]></description></item><item><title>getting started</title><link>https://blog.yakushou.com/posts/udemy/complete-guide-to-elasticsearch/getting-started/</link><pubDate>Tue, 14 Dec 2021 10:38:32 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/udemy/complete-guide-to-elasticsearch/getting-started/</guid><description>Installation 安裝 Elasticsearch 安裝後可以用 http://localhost:9200 確認服務是否正常 Elasticsearch 的檔案目錄 bin 放置執行檔 (Elasticsearch 以外的還有如 plugin 安裝檔 或 cli) config 放置 configuration file elasticsearch.yml 檔案內容是 comment 標起來的，如果不另外把 comment 拿掉的話，系統會使用預設值
best practice 是要註明 cluster.name 和 node.name
data / log 的路徑最好也自行指定 (特別指在 production 上)
這樣即使砍了 Elasticsearch 也不會有資料遺失
jvm.options
用來調整系統的記憶體配置 log4j2.properties
寫 log 的 framework data jdk 包含 OpenJDK lib 包含 Elasticsearch 會用到的 dependency logs modules 包含很多內建的 module plugins Basic architecture 基礎單元是 node，是 Elasticsearch 的 instance，用來儲存 data node 可以執行複數個，各自儲存部分的資料 node 不是機器，所以可以用幾台機器運行更多個 node 每個 node 都隸屬在 cluster 下 cluster 包含 nodes 通常不同的 cluster 會用來做不同的搜尋情境，彼此獨立 資料單位稱為 document，是一筆 json 格式的資料 index a document，意思是送一筆 json object 給 Elasticsearch 該筆 json object 到 Elasticsearch 後會在 &amp;quot;_source&amp;quot; 的節點下，並賦予其他 meta data index 包含多個 document query 的時候，是對指定的 index 做搜尋 document Kibana console 進入 Kibana 介面，並點擊 Dev Tools query HTTP method + request path 範例: 取得 cluster 狀態</description></item><item><title>introduction</title><link>https://blog.yakushou.com/posts/udemy/complete-guide-to-elasticsearch/introduction/</link><pubDate>Tue, 14 Dec 2021 01:13:54 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/udemy/complete-guide-to-elasticsearch/introduction/</guid><description>Introduction to Elasticsearch 儲存一筆資料的單位是 document (類似 RDB 的 row) Document 的欄位叫做 fields (類似 RDB 的 column) 儲存的格式像 json client 透過 REST API 和 Elasticsearch 溝通 Overview of the Elastic Stack Kibana 分析 / 視覺畫的平台 透過 Elasticsearch 的資料來做視覺化 (發 http request) Logstash 處理 log (或其他資料，如訂單) 後把資料送給 Elasticsearch (也可以傳給不同的對象，如 Kafka) 資料處理的 pipeline pipeline 三步驟: input filter output pipeline configuration 的格式像 json X-Pack 提供額外功能給 Elasticsearch 和 Kibana Security authentication authorization Monitoring 視覺化 Elastic Stack 如何運作 (如顯示 CPU / memory usage / disk space) Alerting 設定告警 (如透過 email 通知) Reporting 輸出 Kibana 的資料 Machine Learning enable machine learning for Elasticsearch &amp;amp; Kibana Graph 分析資料的關聯 Elasticsearch SQL 可以傳送 SQL query 給 Elasticsearch Beats 蒐集資料並運送 Walkthrough of common architectures 同時儲存資料在 DB 和 Elasticsearch，後端收到 request 的時候兩邊都做 query</description></item><item><title>Makefile</title><link>https://blog.yakushou.com/posts/programming/makefile/</link><pubDate>Sun, 05 Dec 2021 21:01:05 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/programming/makefile/</guid><description><![CDATA[範例
GREENLIGHT_DB_DSN=&#39;postgres://greenlight:@localhost/greenlight?sslmode=disable&#39; ## help: print this help message .PHONY: help help: @echo &#39;Usage:&#39; @sed -n &#39;s/^##//p&#39; ${MAKEFILE_LIST} | column -t -s &#39;:&#39; | sed -e &#39;s/^/ /&#39; .PHONY: confirm confirm: @echo &#39;Are you sure? [y/N] &#39; &amp;&amp; read ans &amp;&amp; [ $${ans:-N} = y ] ## run/api: run the cmd/api application .PHONY: run/api run/api: go run ./cmd/api ## db/psql: connect to the database using psql .PHONY: db/psql db/psql: psql ${GREENLIGHT_DB_DSN} ## db/migrations/new name=$1: create a new database migration .]]></description></item></channel></rss>