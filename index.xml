<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>YakuShou's NOTEBOOK</title><link>https://blog.yakushou.com/</link><description>YakuShou's NOTEBOOK</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 05 Dec 2021 21:01:05 +0800</lastBuildDate><atom:link href="https://blog.yakushou.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Makefile</title><link>https://blog.yakushou.com/posts/programming/makefile/</link><pubDate>Sun, 05 Dec 2021 21:01:05 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/programming/makefile/</guid><description><![CDATA[範例
GREENLIGHT_DB_DSN=&#39;postgres://greenlight:@localhost/greenlight?sslmode=disable&#39; ## help: print this help message .PHONY: help help: @echo &#39;Usage:&#39; @sed -n &#39;s/^##//p&#39; ${MAKEFILE_LIST} | column -t -s &#39;:&#39; | sed -e &#39;s/^/ /&#39; .PHONY: confirm confirm: @echo &#39;Are you sure? [y/N] &#39; &amp;&amp; read ans &amp;&amp; [ $${ans:-N} = y ] ## run/api: run the cmd/api application .PHONY: run/api run/api: go run ./cmd/api ## db/psql: connect to the database using psql .PHONY: db/psql db/psql: psql ${GREENLIGHT_DB_DSN} ## db/migrations/new name=$1: create a new database migration .]]></description></item><item><title>script</title><link>https://blog.yakushou.com/posts/programming/script/</link><pubDate>Mon, 29 Nov 2021 22:01:31 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/programming/script/</guid><description>範例 script.sh
$ touch script.sh $ chmod +x script.sh 檔案內容
#!/bin/zsh GREENLIGHT_DB_DSN=&amp;#39;postgres://greenlight:@localhost/greenlight?sslmode=disable&amp;#39; echo ${GREENLIGHT_DB_DSN} 運行 script.sh
$ ./script.sh Reference 簡明 Linux Shell Script 入門教學</description></item><item><title>Useful Design Site</title><link>https://blog.yakushou.com/posts/site/useful-design-site/</link><pubDate>Fri, 26 Nov 2021 07:36:16 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/site/useful-design-site/</guid><description>infograpify</description></item><item><title>errors</title><link>https://blog.yakushou.com/posts/golang/packages/errors/</link><pubDate>Tue, 23 Nov 2021 18:26:55 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/packages/errors/</guid><description>#As func As(err error, target interface{}) bool
第一個參數是現在拿到的 error
會透過呼叫 Unwrap 來比對 err 的第一個錯誤是否和 target 相同 如果對的話，會把 target 設定為 err 並回傳 true 否則回傳 false
範例
err := dec.Decode(dst) if err != nil { var syntaxError *json.SyntaxError switch { case errors.As(err, &amp;amp;syntaxError): return fmt.Errorf(&amp;#34;body contains badly-formed JSON (at character %d)&amp;#34;, syntaxError.Offset) default: return err } } #Is func Is(err error, target error) bool
第一個參數是現在拿到的 error 第二個參數是想要比對的特定 error
比對方式是透過呼叫 Unwrap 逐一拆解來比對是否包含 特定的 error</description></item><item><title>json</title><link>https://blog.yakushou.com/posts/golang/packages/json/</link><pubDate>Tue, 23 Nov 2021 17:08:07 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/packages/json/</guid><description><![CDATA[tag 標記用法 範例 json:&quot;name,omitempty&quot;
這個欄位名稱為 name，如果欄位內容是空值的話，則欄位會被忽略
範例 json:&quot;-&quot; 不管欄位名稱是什麼，都會忽略不印出]]></description></item><item><title>golang-migrate</title><link>https://blog.yakushou.com/posts/golang/packages/golang-migrate/</link><pubDate>Sun, 21 Nov 2021 23:36:24 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/packages/golang-migrate/</guid><description>github link
以 postgreSQL 為例
安裝 (用 homebrew) $ brew install golang-migrate 確認版本 $ migrate -version 建立 migration 檔案 # 建立 migration 檔案 $ migrate create -seq -ext=.sql -dir=./migrations create_movies_table -sql : 用數字序列的方式命名 migration 檔案 (如0001, 0002, &amp;hellip;) 預設是用 unix timestamp -ext : 指定 migration 檔案的 extension 名稱 -dir : 表示我們要把 migration 檔案建立在哪個路徑 (若路徑不存在的話會自動建立) create_movies_table 是想要建立的檔案名稱 接著系統會建立兩份 migration 檔案 000001_create_movies_table.down.sql 000001_create_movies_table.up.sql
之後便可在這兩份檔案寫入對應的 SQL 語法
執行 migrate (up) $ export GREENLIGHT_DB_DSN=&amp;#39;postgres://greenlight:@localhost/greenlight?</description></item><item><title>Signal</title><link>https://blog.yakushou.com/posts/golang/signal/</link><pubDate>Sat, 20 Nov 2021 23:24:11 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/signal/</guid><description>Signal 類型 Signal Description Keyboard Shortcut Catchable SIGINT 鍵盤中斷訊號 Ctrl + C true SIGQUIT 鍵盤離開訊號 Ctrl + |true SIGKILL 刪除程序(立即終止) - no SIGTERM 照順序終止程序 - true kill pid 會傳送SIGTERM到程序pid
shutdown() shutdown 的關閉流程不會中斷任何作用中的連線
先關閉所有 open 的 listener 再關閉所有 idle 的 listener 等候作用中連線成為 idle shutdown http.Server 的 Shutdown 會在結束時回傳錯誤碼 (沒錯誤的話回傳 nil)</description></item><item><title>Web Development</title><link>https://blog.yakushou.com/posts/programming/web-development/</link><pubDate>Wed, 17 Nov 2021 16:45:33 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/programming/web-development/</guid><description>web url encoding 在 url 內的 + 代表空白，也可以用 %20 表示 user enumeration 一種可能的帳號攻擊行為
比如說嘗試使用者登入，輸入email 和 密碼
系統顯示 密碼錯誤 而不是 帳號密碼錯誤 或 找不到此使用者
代表這個使用者的 email 信箱是存在且有註冊過這個網站的
即使用者的資訊被其他人知曉
要避免的話，可以統一錯誤訊息或是把錯誤訊息寫得更通用一點
CORS cross-origin requests
origin: 如果兩個 URL 的 scheme, host, port 都相同，
即為相同 origin
(path 不需要相同)
https://foo.com:443/a/
https 是 scheme foo.com 是 host 443 是 port a 是 path web browser 預設是禁止的 網站可以內嵌其他 origin 的資源 一個網站可以傳送資料給不同的 origin 位址 但是一個網站不能夠接收來自不同 origin 的資料 (瀏覽器行為) 可以透過設定 Header 內的 Access-Control 來控制允許或不允洗特定的 cross-origin requests 打我們的 API 藍覽器以外的工具，如 curl, wget 不會受到影響 如果在 API 的 response header 的 Header 的 Access-Control-Allow-Origin 塞值 *</description></item><item><title>Slice</title><link>https://blog.yakushou.com/posts/golang/slice/</link><pubDate>Tue, 16 Nov 2021 22:59:16 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/golang/slice/</guid><description>建立空的 Slice var movies []*Movie movie = &amp;amp;Movie{} // 這樣子建立出來的 movies slice 是 nil // 但已經足夠用來做 append // 不需要寫成 movies := []*Movie{} movies = append(movies, movie) 把 array 轉成 slice // hash 是 [32]byte 的 byte array hash := sha256.Sum256(info) // b.Hash 是 byte slice b.Hash = hash[:]</description></item><item><title>英文: 俚語</title><link>https://blog.yakushou.com/posts/dictionary/en-slang-dictionary/</link><pubDate>Mon, 15 Nov 2021 21:03:22 +0800</pubDate><author><name>yakushou730</name><uri>https://github.com/yakushou730</uri><email>yakushou730@gmail.com</email></author><guid>https://blog.yakushou.com/posts/dictionary/en-slang-dictionary/</guid><description>G gotcha （為了嚇人或表示佔了上風時的用語）抓住你了</description></item></channel></rss>