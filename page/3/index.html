<!doctype html><html lang=en>
<head>
<meta name=generator content="Hugo 0.89.2">
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<title class=pjax-title>YakuShou's NOTEBOOK</title><meta name=Description content><meta property="og:title" content="YakuShou's NOTEBOOK">
<meta property="og:description" content>
<meta property="og:type" content="website">
<meta property="og:url" content="https://blog.yakushou.com/">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="YakuShou's NOTEBOOK">
<meta name=twitter:description content>
<meta name=application-name content="YakuShou's NOTEBOOK">
<meta name=apple-mobile-web-app-title content="YakuShou's NOTEBOOK">
<meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://blog.yakushou.com/><link rel=alternate href=/index.xml type=application/rss+xml title="YakuShou's NOTEBOOK">
<link rel=feed href=/index.xml type=application/rss+xml title="YakuShou's NOTEBOOK"><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/fontawesome-free/all.min.css>
<noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload="this.onload=null,this.rel='stylesheet'" href=/lib/animate/animate.min.css>
<noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","url":"https:\/\/blog.yakushou.com\/","inLanguage":"en","name":"YakuShou's NOTEBOOK"}</script></head>
<body header-desktop header-mobile><script type=text/javascript>function setTheme(a){document.body.setAttribute('theme',a)}function saveTheme(a){window.localStorage&&localStorage.setItem('theme',a)}function getMeta(b){const a=document.getElementsByTagName('meta');for(let c=0;c<a.length;c++)if(a[c].getAttribute('name')===b)return a[c];return''}if(window.localStorage&&localStorage.getItem('theme')){let a=localStorage.getItem('theme');a==='light'||a==='dark'||a==='black'?setTheme(a):window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches?setTheme('dark'):setTheme('light')}else''==='light'||''==='dark'||''==='black'?(setTheme(''),saveTheme('')):(saveTheme('auto'),window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches?setTheme('dark'):setTheme('light'));let metaColors={light:'#f8f8f8',dark:'#252627',black:'#000000'};getMeta('theme-color').content=metaColors[document.body.getAttribute('theme')]</script>
<div id=back-to-top></div>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="YakuShou's NOTEBOOK">YakuShou's NOTEBOOK</a>
</div>
<div class=menu>
<div class=menu-inner><a class=menu-item href=/posts/> Posts </a><a class=menu-item href=/tags/> Tags </a><span class="menu-item delimiter"></span><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a></div>
</div>
</div>
</header><header class=mobile id=header-mobile>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="YakuShou's NOTEBOOK">YakuShou's NOTEBOOK</a>
</div>
<div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div>
</div>
<div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a></div>
</div>
</header>
<div class="search-dropdown desktop">
<div id=search-dropdown-desktop></div>
</div>
<div class="search-dropdown mobile">
<div id=search-dropdown-mobile></div>
</div>
<main class=main>
<div class=container><div class="page home" posts><div class=home-profile></div>
<article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline">
<a href=/posts/k8s/helm/>helm</a>
</h1><div class=post-meta>
<span class=post-author><span class=author><i class="author fas fa-user-circle fa-fw"></i><span class=screen-reader-text> </span><a href=https://blog.yakushou.com/authors/yakushou730>yakushou730</a></span>
</span>&nbsp;<span class=post-publish>published on <time datetime=2022-01-06>2022-01-06</time></span></div><div class=content>What is Helm 一般來說，要 deploy 一個服務，即使是簡單的 app
也要建立一整套完整的 k8s 元件
ex: Secret, Deployment, Service, PersistentVolumeClaim&mldr; 等等，需要 apply 一堆 yaml 檔案
Helm 被稱為 k8s 的 package manager
想像一個遊戲由千百個檔案組成
我們不需要自己處理那摩多檔案，透過安裝程式的方式
做到一次安裝一個完整的遊戲，對應的檔案也都被安裝到正確的位置
而 Helm 就像這樣，一次處理一堆 YAML 檔案和 K8s 物件，來設定 application
Helm 讓我們操作 k8s 的元件就像操作 app 一樣，而不是一堆檔案物件
# 透過 helm 安裝 wordpress helm install wordpress # 修改完 yaml 檔案套用 helm upgrade wordpress # 可倒退版本 helm rollback wordpress # 移除 wordpress helm uninstall wordpress # debug 資訊 helm --debug Helm2 vs Helm3 Helm3 多了</div><div class=post-footer>
<a href=/posts/k8s/helm/>Read more...</a><div class=post-tags>
<i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/programming/>programming</a>,&nbsp;<a href=/tags/k8s/>k8s</a></div></div>
</article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline">
<a href=/posts/k8s/kind/>kind</a>
</h1><div class=post-meta>
<span class=post-author><span class=author><i class="author fas fa-user-circle fa-fw"></i><span class=screen-reader-text> </span><a href=https://blog.yakushou.com/authors/yakushou730>yakushou730</a></span>
</span>&nbsp;<span class=post-publish>published on <time datetime=2022-01-03>2022-01-03</time></span></div><div class=content>kind official page
kind 可以用來在 local 建立 k8s cluster
# 安裝 kind brew install kind # 建立 cluster kind create cluster # 查看 clusters kind get clusters # 查看 kind 的 kubeconfig kind get kubeconfig # 切換到 kind cluster kubectl config use-context kind-kind # 查看 cluster 狀態 kubectl cluster-info </div><div class=post-footer>
<a href=/posts/k8s/kind/>Read more...</a><div class=post-tags>
<i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/programming/>programming</a>,&nbsp;<a href=/tags/k8s/>k8s</a></div></div>
</article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline">
<a href=/posts/devops/gitops/>gitops</a>
</h1><div class=post-meta>
<span class=post-author><span class=author><i class="author fas fa-user-circle fa-fw"></i><span class=screen-reader-text> </span><a href=https://blog.yakushou.com/authors/yakushou730>yakushou730</a></span>
</span>&nbsp;<span class=post-publish>published on <time datetime=2022-01-02>2022-01-02</time></span></div><div class=content>What is GitOps 為了避免手動 deploy 而提出的解決方案
Infrastructure as Code 提倡後，大家會把 infrastructure 寫成 code 以後管控
但是針對變更 infrastructure 仍然後是在本機安裝工具後手動變更 (ex: ansible / terraform&mldr;)
GitOps 提倡一切 (infrastructure/network/policy/configuration/security&mldr;) 都以 YAML 的形式放在 git 上，並且透過 PR 自動更新資源
GitOps flow Create Pull/Merge Request 任何人都可以發 PR，大家可以 review Run CI pipeline 驗證 configuration files 跑自動化測試 Approve Changes 到這步代表 code 是經過測試以及 well reviewed Run CD Pipeline merge 回 main 以後觸發 CD pipeline 部署到 aws/k8s&mldr;等等 優點:</div><div class=post-footer>
<a href=/posts/devops/gitops/>Read more...</a><div class=post-tags>
<i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/programming/>programming</a>,&nbsp;<a href=/tags/devops/>devops</a></div></div>
</article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline">
<a href=/posts/devops/flux/>flux</a>
</h1><div class=post-meta>
<span class=post-author><span class=author><i class="author fas fa-user-circle fa-fw"></i><span class=screen-reader-text> </span><a href=https://blog.yakushou.com/authors/yakushou730>yakushou730</a></span>
</span>&nbsp;<span class=post-publish>published on <time datetime=2022-01-02>2022-01-02</time></span></div><div class=content>目前看起來像是 K8S 的 CD 工具
Flux 是什麼? Flux 是一組用於 k8s 的 delivery solution
Flux 提供 GitOps for apps 和 infrastructure Flux 和 Flagger 提供 canaries/feature flags/AB rollouts 來部署 app 可用來管理 k8s 資源 推 git 以後，剩下的 Flux 會處理 可套用 CD (by Flagger) 和 PD (progressive delivery) container image 發生更新後，Flux 可以自動推 git Flux 相容現有的工具 含 github/gitlab/bitbucket/s3&mldr;，以及全部有提供 cli 的 provider Flux 可用於任何 k8s 和所有常見的 k8s 工具 Kustomize/Helm/RBAC&mldr;等等 Flux 處理 multi-everything 可以處理多數個 cluster Flux 有告警和提示 只要 git push，可以得到通知 使用者信任 Flux Flux 是 CNCF 孵化出的專案 Flux 有友善的社群 任何人都可以貢獻 Flux 是一組 k8s 用的工具，可以 sync 資源設定 (像 git repository)</div><div class=post-footer>
<a href=/posts/devops/flux/>Read more...</a><div class=post-tags>
<i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/programming/>programming</a>,&nbsp;<a href=/tags/devops/>devops</a></div></div>
</article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline">
<a href=/posts/programming/git/>git</a>
</h1><div class=post-meta>
<span class=post-author><span class=author><i class="author fas fa-user-circle fa-fw"></i><span class=screen-reader-text> </span><a href=https://blog.yakushou.com/authors/yakushou730>yakushou730</a></span>
</span>&nbsp;<span class=post-publish>published on <time datetime=2022-01-02>2022-01-02</time></span></div><div class=content>使用標籤 tag # 建立標籤 git tag v1.0.0 -am "description for this tag v1.0.0" # 刪除標籤 git tag -d v1.0.0 # 把標籤推到 github 上 (預設的 git push 是不推 tag 的，所以要自己下 flag 指令) git push --tags </div><div class=post-footer>
<a href=/posts/programming/git/>Read more...</a><div class=post-tags>
<i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/programming/>programming</a>,&nbsp;<a href=/tags/git/>git</a></div></div>
</article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline">
<a href=/posts/devops/basics/>basics</a>
</h1><div class=post-meta>
<span class=post-author><span class=author><i class="author fas fa-user-circle fa-fw"></i><span class=screen-reader-text> </span><a href=https://blog.yakushou.com/authors/yakushou730>yakushou730</a></span>
</span>&nbsp;<span class=post-publish>published on <time datetime=2022-01-02>2022-01-02</time></span></div><div class=content>Environment variable SHELL: 系統使用了哪種 shell 確認 OS Version # 印出所有 release 版本 # * 是指 wildcard ls /etc/*release* # 印出當前版本細節 cat /etc/*release* package managers RPM (Red Hat Package Manager)
RPM 不管 dependency CentOS Red Hat Enterprise Linux Fedora package 會被包裝成 &lt;檔名>.rpm
# install package rpm -i telnet.rpm # uninstall package rpm -e telnet.rpm # query package rpm -q telnet.rpm # query all installed package rpm -qa YUM 包裝過 rpm，會順便安裝 dependency</div><div class=post-footer>
<a href=/posts/devops/basics/>Read more...</a><div class=post-tags>
<i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/programming/>programming</a>,&nbsp;<a href=/tags/devops/>devops</a></div></div>
</article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline">
<a href=/posts/k8s/yaml-files/>YAML Files</a>
</h1><div class=post-meta>
<span class=post-author><span class=author><i class="author fas fa-user-circle fa-fw"></i><span class=screen-reader-text> </span><a href=https://blog.yakushou.com/authors/yakushou730>yakushou730</a></span>
</span>&nbsp;<span class=post-publish>published on <time datetime=2021-12-28>2021-12-28</time></span></div><div class=content>General YAML template 必要的 4 個欄位
apiVersion:# 要用來建立物件的 k8s API 版本 kind:# 要建立的物件metadata:# 物件的其他資訊，如 name, labels...spec:# 建立物件需要的訊息 apiVersion (string) POD: v1 Service: v1 ReplicaSet: apps/v1 Deployment: apps/v1 kind (string) Pod Service ReplicaSet Deployment metadata (dictionary) name labels labels 下的 key/value 值是可以自訂的 spec (dictionary) 指令:
# 可以看介紹 kubectl explain &lt;k8s kind> POD with YAML pod-definition.yaml
apiVersion:v1kind:Podmetadata:name:myapp-podlabels:app:myapptype:front-endspec:containers:- name:nginx-containerimage:nginx指令
# 建立 kubectl create -f pod-definition.</div><div class=post-footer>
<a href=/posts/k8s/yaml-files/>Read more...</a><div class=post-tags>
<i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/programming/>programming</a>,&nbsp;<a href=/tags/k8s/>k8s</a></div></div>
</article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline">
<a href=/posts/k8s/concepts/>concepts</a>
</h1><div class=post-meta>
<span class=post-author><span class=author><i class="author fas fa-user-circle fa-fw"></i><span class=screen-reader-text> </span><a href=https://blog.yakushou.com/authors/yakushou730>yakushou730</a></span>
</span>&nbsp;<span class=post-publish>published on <time datetime=2021-12-28>2021-12-28</time></span></div><div class=content>概念 Container + Orchestration
k8s 是一種容器編排技術，用於協調數百個對象的部署和管理 cluster 中的數千個容器
VM vs Docker VM 是在 原本的 OS 上，再額外起來的完整的虛擬機器，具有完整的虛擬 OS 每個 VM 裡面除了 OS 外還有各自的 libs 和 deps 動輒以 GB 為單位 啟動速度慢 Docker 是基於原本的內核，起起來的 container libs 和 deps 在各自容器內 大約以 MB 為單位 啟動速度快 術語 node (minion) 安裝了 k8s 的機器，container 會起在這上面 cluster 一組複數個 nodes ( 1 個 master / 多個 worker) 會有一台 master node，負責監管和負責流程編排 node 上 的 container components 安裝 k8s 時，會安裝的一些元件 API server 可以作為 k8s 的前端 (系統操作入口) 不管是使用者對 k8s 或是 node 對 master 都是透過 apiserver 溝通 唯一可以和 etcd 溝通的元件，其他元件都必須透過 apiserver 才能訪問集群狀態 以 RESTful interface 提供外部或內部組件使用 etcd key-value store 確保 master 間沒有 conflict kubelet 每個 node 都會安裝的 agent 確保 container 可以運作在 node 上 container runtime 用來跑 container 的環境 (ex: Docker) controller manager 負責 k8s cluster 故障檢測和恢復的自動化，執行多種 controller replication controller 定期關聯 replication controller 和 pod，保證 pod 數量正確 node controller kubelet 啟動的時候會通過 apiserver 註冊自己本身節點的資訊，定時向 apiserver 報告狀態 apiserver 收到後更新到 etcd node controller 實現管理和監控 node 資訊 resourceQuota controller 用來管理使用的資源不要超過設定 namespace controller 用戶透過 apiserver 可以建立新的 namespace，存於 etcd service account controller 確保 default 的 ServiceAccount 在每個 namespace 中都存在 token controller 用來監聽 service account 的建立/刪除 和 監聽 secret 的增加/刪除 service controller 監聽 service 的變化 endpoint controller endpoint 表示了 service 對應的所有 pod 副本的位址 而 endpoint controller 是負責生成和維護所有 endpoints 的控制器，保證 service 到 pod 的對應總是最新的 orchestration 的大腦，在 nodes / containers 發生故障時發出通知和回應 決定是否建立新的 container scheduler 分配 container 給 nodes master 上 會安裝 kube-apiserver 會安裝 etcd 儲存資訊 會安裝 controller 會安裝 scheduler worker 上 會安裝 kubelet 和 master 溝通 k8s component 的 kind 種類 ConfigMap</div><div class=post-footer>
<a href=/posts/k8s/concepts/>Read more...</a><div class=post-tags>
<i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/programming/>programming</a>,&nbsp;<a href=/tags/k8s/>k8s</a></div></div>
</article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline">
<a href=/posts/programming/software/>software</a>
</h1><div class=post-meta>
<span class=post-author><span class=author><i class="author fas fa-user-circle fa-fw"></i><span class=screen-reader-text> </span><a href=https://blog.yakushou.com/authors/yakushou730>yakushou730</a></span>
</span>&nbsp;<span class=post-publish>published on <time datetime=2021-12-27>2021-12-27</time></span></div><div class=content>Declarative vs imperative language Declarative programming (宣告式)
What 代表為 functional programming (function 之間不會互相共用狀態) 程式碼通常是可以直接看到在做什麼 (重視 what) Imperative programming (命令式)
how to do 代表為 OOP (狀態互相依賴) 看得見邏輯運算過程 (how to do) Repository Pattern Repository Pattern 是在 domain 和 data mapping 的中間層
透過 collection-like 的 interface 來存取 domain object
換句話說可以是 application 和 data access logic 的中間層
好處:
修改邏輯的時候只要改一個地方 測試 controller 變簡單了，不用真實存取資料庫資料 舉例: EmployeeController -> Employee Repository -> SQL server Database</div><div class=post-footer>
<a href=/posts/programming/software/>Read more...</a><div class=post-tags>
<i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/programming/>programming</a></div></div>
</article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline">
<a href=/posts/golang/fundamental1/>fundamental1</a>
</h1><div class=post-meta>
<span class=post-author><span class=author><i class="author fas fa-user-circle fa-fw"></i><span class=screen-reader-text> </span><a href=https://blog.yakushou.com/authors/yakushou730>yakushou730</a></span>
</span>&nbsp;<span class=post-publish>published on <time datetime=2021-12-27>2021-12-27</time></span></div><div class=content>in memory 程式的用法在記憶體上會切成很多小區塊，每一塊我們稱為 word
32 bits CPU: 1 word = 32bits = 4 bytes 64 bits CPU: 1 word = 64bits = 8 bytes
如何在 go get 的時候可以拉到 private repo 概念:
因為是 private repo 的關係， 所以要讓 go 有權限去拉
拉的時候是透過 git，所以要設定具有權限的 token 給 git
在個人的 github settings 建立一個可以拉取 private repo 的 token 把 token 記下以後，在本機操作 git cli 用 copy 下來的 token 取代下列的 GITHUB_TOKEN $ git config --global url."https://${GITHUB_TOKEN}@github.com".insteadOf "https://github.com" Type Assertion vs Type Conversion Type Assertion (斷言)</div><div class=post-footer>
<a href=/posts/golang/fundamental1/>Read more...</a><div class=post-tags>
<i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/programming/>programming</a>,&nbsp;<a href=/tags/golang/>golang</a></div></div>
</article><ul class=pagination><li class=page-item>
<span class=page-link>
<a href=/>1</a>
</span>
</li><li class=page-item>
<span class=page-link>
<a href=/page/2/>2</a>
</span>
</li><li class="page-item active">
<span class=page-link>
<a href=/page/3/>3</a>
</span>
</li><li class=page-item>
<span class=page-link>
<a href=/page/4/>4</a>
</span>
</li><li class=page-item>
<span class=page-link>
<a href=/page/5/>5</a>
</span>
</li><li class=page-item>
<span class=page-link aria-hidden=true>&mldr;</span>
</li><li class=page-item>
<span class=page-link>
<a href=/page/7/>7</a>
</span>
</li></ul></div></div>
</main><footer class=footer>
<div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.89.2">Hugo</a> | Theme - <a href=https://github.com/HEIGE-PCloud/DoIt target=_blank rel="noopener noreffer" title="DoIt 0.2.13"><i class="far fa-edit fa-fw"></i> DoIt</a>
</div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank rel="noopener noreferrer"></a></span></div>
</div></footer></div>
<div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title="Back to Top">
<i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments">
<i class="fas fa-comment fa-fw"></i>
</a>
</div><div class=assets><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/topbar/topbar.min.js></script><script type=text/javascript src=/lib/pjax/pjax.min.js></script><script type=text/javascript src=/js/theme.min.js></script></div>
<div class=pjax-assets><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:10}}</script></div>
</body>
</html>